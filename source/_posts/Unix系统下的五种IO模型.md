---
title: Unix系统下的五种IO模型
date: 2021-03-10 20:00:00
tags: [计算机网络]
categories: 编程
---

> Unix系统下，I/O模型一共有五种：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O和异步I/O

# I/O?

I/O（Input/Output）即输入/输出。

**从计算机结构的角度来解读一下 I/O。**

根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。

![微信图片_20210310114716](Unix系统下的五种IO模型\微信图片_20210310114716.jpg)

输入设备（比如键盘）和输出设备（比如鼠标）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。

输入设备向计算机输入数据，输出设备接收计算机输出的数据。

从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。

**再先从应用程序的角度来解读一下 I/O。**

为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space）**和 **内核空间（Kernel space ）** 。

像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。

并且，用户空间的程序不能直接访问内核空间。

当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。

因此，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间。

我们在平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和相应）**。

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据

2. 内核将数据从内核空间拷贝到用户空间。

IO模型的区别主要都在这两个阶段上面所以很重要，我们所说的同步与异步的区别，在于第二个阶段中，将数据从内核拷贝到线程（或进程）中，如果被阻塞了就同步，没有被阻塞就是异步。被阻塞了说明该阶段的操作是依赖用户线程的，而没有被阻塞说明不依赖用户线程，而依赖内核，所以异步是需要操作系统内核支持的。

阻塞IO与非阻塞IO则是发生在IO操作第一个阶段的。

阻塞IO是指当一个线程发起IO操作请求时，系统内核会去查看要操作的数据是否就绪，当是阻塞IO时，发现要操作是数据没有就绪，就会一直等待下去，直到数据准备就绪；当是非阻塞IO时如果数据没有准备好，就会返回一个标识信息告诉调用线程，当前操作数据没有准备就绪。当数据准备就绪后才会执行第一阶段。

其实阻塞IO与非阻塞IO的关键区别在于，是等待执行，还是说立即返回一个通知标识。当数据没有准备好时就等待执行，而当立即返回一个通知标识时，线程会根据标识知道现在数据是个什么情况，如果没有准备好，那么线程会再次发起请求，知道数据准备好后立即执行。

# 同步和异步？

同步就是多个任务或事件在执行时需要按顺序逐个执行，如果排在顺序前面的任务或事件在执行的时候，排在后面的任务或事件就需要等待前面的执行完后才可以执行，这些任务或事件是不能并行执行的。同步执行任务可以被设计为可靠的任务序列，前后两个任务可以保持一致才算整个任务结束。

异步是多个任务或事件可以同时并行执行，前面的任务不会导致后面的任务的等待。因为是多个任务同时进行的，所以每个任务之间不产生相互的依赖，所以无法保证可靠性。

同步流程图

![772743-20190902235132996-660324540](Unix系统下的五种IO模型\772743-20190902235132996-660324540.png)

异步流程图

![772743-20190903000032601-1472302618](Unix系统下的五种IO模型\772743-20190903000032601-1472302618.png)

# 阻塞和非阻塞？

阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，那么就会一直等待，直到条件满足后，才继续执行后面的其他工作。

非阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，会立即返回一个标志信息告知条件不满足，而不会一直在等待下去。

阻塞流程

![772743-20190903010837823-947403378](Unix系统下的五种IO模型\772743-20190903010837823-947403378.png)

非阻塞流程

![772743-20190903011515281-2072868827](Unix系统下的五种IO模型\772743-20190903011515281-2072868827.png)

同步与异步这组概念的重点在于，前面的任务是否会导致整个流程的等待。

阻塞与非阻塞这组概念的重点在于，如果操作请求不满足条件是否会返回一个标志信息告知不满足条件。

其实理解阻塞与非阻塞可以从我们通常所接触的线程阻塞来理解，当出现慢任务的时候，线程会发生阻塞，cpu会等待慢任务执行完成后再执行后续的任务。而非阻塞线程在执行这个慢任务的时候，会去做其他事情，当慢任务执行完成后，再去执行后面的任务。非阻塞虽然看似可以明显提高效率，但是系统的线程切换也是会造成时间损耗，所以需要合理利用。

# 组合分析

| 组合方式   | 性能分析                                                     |
| ---------- | ------------------------------------------------------------ |
| 同步阻塞   | 最常用的一种用法，使用也是最简单的，但是I/O性能一般很差，CPU大部分处于空闲状态。 |
| 同步非阻塞 | 提升I/O性能的常用手段，就是将I/O的阻塞改为非阻塞方式，尤其在网络I/O是长连接同时传输数据也不很多的情况下，提升性能非常有效。这种方式通常能提升I/O性能，但是会增加CPU消耗，要考虑增加的I/O性能能不能补偿CPU的消耗，也就是系统的瓶颈是在I/O上还是在CPU上。 |
| 异步阻塞   | 这种方式在分布式数据库中经常用到，例如，在一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写I/O。异步阻塞对网络I/O能够提升效率，尤其像上面这种同时写多份相同数据的情况。 |
| 异步非阻塞 | 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下用，集群之间的消息同步机制一般用这种I/O组合方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大却非常频繁的情况。这种网络I/O用此方式性能达到最高。 |

# IO模型

## BIO(Blocking I/O)

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。

![微信截图_20210310142515](Unix系统下的五种IO模型\微信截图_20210310142515.png)

在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

## NIO(Non-blocking/New I/O)

Java 中的 NIO 于 Java 1.4 中引入，对应 `java.nio` 包，提供了 `Channel` , `Selector`，`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。

**同步非阻塞 IO 模型**

![20210310142328](Unix系统下的五种IO模型\20210310142328.png)

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。

但是，这种 IO 模型同样存在问题：**应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。**

## I/O 多路复用模型

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。

![微信图片_20210310142237](Unix系统下的五种IO模型\微信图片_20210310142237.png)

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。

> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
>
> - **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> - **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

![微信截图_20210310142158](Unix系统下的五种IO模型\微信截图_20210310142158.png)

## 信号驱动IO模型

在信号驱动IO模型中，让内核在数据报准备就绪时发送SIGIO信号通知用户线程。

![772743-20190922172245805-84723612](Unix系统下的五种IO模型\772743-20190922172245805-84723612.png)

首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，也就是说没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后就可以在信号处理函数中调用recvfrom读取数据报，并通知用户进程数据已经准备好了，可以读取了。

这种模型的优点在于等待数据报到达期间不会被阻塞，用户进程可以继续执行，只要等待来自信号处理函数的通知即可。

## AIO (Asynchronous I/O)

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

![微信图片_20210310141857](Unix系统下的五种IO模型\微信图片_20210310141857.png)

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。

# 总结

![微信图片_20210310141745](Unix系统下的五种IO模型\微信图片_20210310141745.png)
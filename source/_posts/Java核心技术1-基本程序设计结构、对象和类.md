---
title: Java核心技术1-基本程序设计结构、对象和类
date: 2019-03-16 13:46:00
tags: [java,技术书籍]
categories: 编程
---

> 读《Java核心技术1》记录知识点

# 基本程序设计结构

1. switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到
   switch语句的结束处为止。如果没有相匹配的 case 标签， 而有 default 子句， 就执行这个子句。 

2. break和continue的区别？

   用break语句可以使流程跳出switch语句体，也可以用break语句在循环结构终止本层循环体，从而提前结束本层循环。

   continue语句的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环。

3. 如果基本的整数和浮点数精度不能够满足需求， 那么可以使用 java.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。
   Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。
   使用静态的 valueOf 方法可以将普通的数值转换为大数值：
   Biglnteger a = Biglnteger.valueOf(100);
   遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数值类中的 add 和 multiply 方法。
4. 数组是一种数据结构，用来存储同一类型值的集合。  

5. 创建一个数字数组时，所有元素都初始化为 0。boolean 数组的元素会初始化为 false。 对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。 

6. 一旦创建了数组， 就不能再改变它的大小（尽管可以改变每一个数组元素）0 如果经常需要在运行过程中扩展数组的大小， 就应该使用另一种数据结构—数组列表（ array list)  

7. Arrays.toString(a), 返回一个包含数组元素的字符串 

8. 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法。
   这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较
   高的。 

# 对象和类

1. 类与类常见的关系：依赖、聚合、继承

2. 类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类：
   一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。 

3. final实例域:可以将实例域定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。 

4. 由于每个类对象都可以对公有域进行修改， 所以，最好不要将域设计为 public。然而， 公有常量（即 final 域）却没问题。

5. 静态方法的另一种常见用途：工厂方法。为什么要使用工厂方法？

   * 无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例
     和百分比实例采用不用的名字。
   * 当使用构造器时，无法改变所构造的对象类型。 

6. 方法参数：按值调用 （call by value) 表示方法接收的是调用者提供的值。 而按引用调用 （ call by reference)表示方法接收的是调用者提供的变量地址。 一个方法可以修改传递引用所对应的变量值， 而不能修改传递值调用所对应的变量值 。

7. 方法参数共有两种类型：
   •基本数据类型（数字、布尔值）。
   •对象引用。 

8. Java 中方法参数的使用情况：

   * 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
   * 一个方法可以改变一个对象参数的状态。
   * 一个方法不能让对象参数引用一个新的对象。 

9. 对象构造

   9.1 重载：（类可以有多个构造器）如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution)。） 

   9.1.1 方法签名：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名 。

   ​	返回类型不是方法签名的一部分。也就是说，不能有两个相同方法名，相同参数，但返回类型不同的方	法。

   9.2 默认域初始化 ： 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。 
   

这是域与局部变量的主要不同点。 必须明确地初始化方法中的局部变量。 但是，如果没有初始化类中的域， 将会被自动初始化为默认值（ 0、 false 或 null )。 

9.3 无参数的构造器 ：如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是， 实例域中的数值型数据设置为 0、 布尔型数据设置为 false、 所有对象变量将设置为 null。 

如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。 

9.4 显式域初始化 : 通过重载类的构造器方法， 可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。 

9.5 调用另一个构造器 ：关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。
   如果构造器的第一个语句形如 this(...)， 这个构造器将调用同一个类的另一个构造器。 

9.6 初始化块:无论使用哪个构造器构造对象， id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。
   这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。 

	9.6.1 初始化数据域的方法： 

   1. 在构造器中设置值 
   2. 在声明中赋值 
   3. 初始化块

​	9.6.2 调用构造器的具体处理步骤： 
   1. 所有数据域被初始化为默认值（0、 false 或 null。) 
   2. 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。 
   3. 如果构造器第一行调用了第二个构造器， 则执行第二个构造器主体 。
   4. 执行这个构造器的主体。


10. 可以为任何一个类添加 finalize 方法。 finalize 方法将在垃圾回收器清除对象之前调用。
    在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时才能够调用。 
11. 一个类可以使用所属包中的所有类， 以及其他包中的公有类 。
12. 包的作用域：标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。 如果没有指定 public 或 private, 这 个 部分（类、方法或变量）可以被同一个包中的所有方法访问。 


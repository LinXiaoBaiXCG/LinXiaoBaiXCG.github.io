<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API接口签名实现</title>
    <url>/2021/02/04/API%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p> 近期，公司小游戏涉及上传得分操作，为防止用户通过篡改接口数据刷游戏榜单获得奖金。最终通过签名的方式设计接口，解决数据被篡改问题。</p>
</blockquote>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>接口签名是主流的通信安全解决方案。</p>
<p>优点：</p>
<ol>
<li>能有效防止数据被篡改</li>
<li>能检验请求来源是否合法</li>
<li>能检验请求是否具有唯一性</li>
</ol>
<p>接口签名主要是请求方和接口提供方约定一个加密规则。请求方按照约定好的算法生成签名字符串，接口提供方验算签名即可知是否合法。</p>
<p>步骤通常如下：</p>
<ol>
<li>接口提供方给出appid和appsecret</li>
<li>调用方根据appid和appsecret以及请求参数和时间戳，按照约定好的算法生成签名sign</li>
<li>接口提供方验证签名</li>
</ol>
<p>项目中需求是防止数据被篡改，最终简化为如下步骤：</p>
<ol>
<li>调用方对请求参数排序后加盐进行MD5加密，然后转为大写</li>
<li>然后使用公钥对MD5再次加密，生成最终的签名sign</li>
<li>接口提供方对签名sign进行校验</li>
</ol>
<p>这里用到签名算法是MD5摘要算法和RSA非对称加密算法。<a href="https://linxiaobaixcg.github.io/2020/10/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">软件系统中常见的加密算法和实现</a></p>
<p>以上步骤能有效防止数据被篡改，但无法校验请求来源是否合法和唯一性</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="客户端加密示例"><a href="#客户端加密示例" class="headerlink" title="客户端加密示例"></a>客户端加密示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数拼接和排序</span></span><br><span class="line">String data = <span class="string">&quot;a:&quot;</span> + <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b:&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;salt:&quot;</span> + <span class="string">&quot;salt&quot;</span>;</span><br><span class="line"><span class="comment">// MD5加密后转大写</span></span><br><span class="line">Digester md5 = <span class="keyword">new</span> Digester(DigestAlgorithm.MD5);</span><br><span class="line">String digestHex = md5.digestHex(data).toUpperCase();</span><br><span class="line"><span class="comment">// 使用公钥加密得到sign</span></span><br><span class="line">RSA rsa = <span class="keyword">new</span> RSA(<span class="keyword">null</span>, <span class="string">&quot;这里是公钥&quot;</span>);</span><br><span class="line">String sign = rsa.encryptBase64(digestHex, KeyType.PublicKey);</span><br></pre></td></tr></table></figure>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拼接MD5加密数据</span></span><br><span class="line">String data = <span class="string">&quot;a:&quot;</span> + <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b:&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;salt:&quot;</span> + <span class="string">&quot;salt&quot;</span>;</span><br><span class="line"><span class="comment">// 对得分和盐进行MD5加密并转为大写</span></span><br><span class="line">Digester md5 = <span class="keyword">new</span> Digester(DigestAlgorithm.MD5);</span><br><span class="line">String upperMD5 = md5.digestHex(data).toUpperCase();</span><br><span class="line"><span class="comment">// 对sign进行私钥解密</span></span><br><span class="line">RSA rsa = <span class="keyword">new</span> RSA(privateKey, <span class="keyword">null</span>);</span><br><span class="line">String decryptSign = <span class="keyword">new</span> String(rsa.decrypt(<span class="string">&quot;调用方请求的sign&quot;</span>, KeyType.PrivateKey));</span><br><span class="line"><span class="comment">// 用sign和解密字符串进行比较</span></span><br><span class="line"><span class="keyword">if</span> (upperMD5.equals(decryptSign)) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>余华--活着 观后感</title>
    <url>/2019/03/18/2019-03-18-%5B%E4%BD%99%E5%8D%8E--%E6%B4%BB%E7%9D%80%5D%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>余华，1960年4月3日生于浙江<a href="https://baike.baidu.com/item/%E6%9D%AD%E5%B7%9E/147639">杭州</a>，当代作家。<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E4%BD%9C%E5%AE%B6%E5%8D%8F%E4%BC%9A/2049478">中国作家协会</a>第九届全国委员会委员。</p>
<p>1977年中学毕业后，进入北京<a href="https://baike.baidu.com/item/%E9%B2%81%E8%BF%85%E6%96%87%E5%AD%A6%E9%99%A2">鲁迅文学院</a>进修深造。1983年开始创作，同年进入浙江省海盐县文化馆。1984年开始发表小说，《<a href="https://baike.baidu.com/item/%E6%B4%BB%E7%9D%80/10565923">活着</a>》和《<a href="https://baike.baidu.com/item/%E8%AE%B8%E4%B8%89%E8%A7%82%E5%8D%96%E8%A1%80%E8%AE%B0">许三观卖血记</a>》同时入选百位批评家和文学编辑评选的九十年代最具有影响的十部作品。1998年获意大利<a href="https://baike.baidu.com/item/%E6%A0%BC%E6%9E%97%E6%89%8E%E7%BA%B3%C2%B7%E5%8D%A1%E4%BD%9B%E6%96%87%E5%AD%A6%E5%A5%96/20119469">格林扎纳·卡佛文学奖</a>。2005年获得<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E5%9B%BE%E4%B9%A6%E7%89%B9%E6%AE%8A%E8%B4%A1%E7%8C%AE%E5%A5%96/3349145">中华图书特殊贡献奖</a>。现就职于杭州文联。</p>
<p>参考：百度百科：<a href="https://baike.baidu.com/item/余华/6935">https://baike.baidu.com/item/余华/6935</a></p>
<h2 id="作品简介"><a href="#作品简介" class="headerlink" title="作品简介"></a>作品简介</h2><p>《活着(新版)》讲述了农村人福贵悲惨的人生遭遇。福贵本是个阔少爷，可他嗜赌如命，终于赌光了家业，一贫如洗。他的父亲被他活活气死，母亲则在穷困中患了重病，福贵前去求药，却在途中被国民党抓去当壮丁。经过几番波折回到家里，才知道母亲早已去世，妻子家珍含辛茹苦地养大两个儿女。此后更加悲惨的命运一次又一次降临到福贵身上，他的妻子、儿女和孙子相继死去，最后只剩福贵和一头老牛相依为命，但老人依旧活着，仿佛比往日更加洒脱与坚强。</p>
<p>《活着(新版)》荣获意大利格林扎纳•卡佛文学奖最高奖项（1998年）、台湾《中国时报》10本好书奖（1994年）、香港“博益”15本好书奖（1994年）、第三届世界华文“冰心文学奖”（2002年），入选香港《亚洲周刊》评选的“20世纪中文小说百年百强”、中国百位批评家和文学编辑评选的“20世纪90年代最有影响的10部作品”。</p>
<p>参考：豆瓣：<a href="https://book.douban.com/subject/4913064/">https://book.douban.com/subject/4913064/</a></p>
<h2 id="个人观后感"><a href="#个人观后感" class="headerlink" title="个人观后感"></a>个人观后感</h2><p>阅读完本书给我的最大感受是当你的生活衣食无忧且资产富足的时候，你可以选择安逸的去生活，或者简简单单的过着你想要的生活。绝不要去挥霍，否则很可能再怎么努力都可能无法挽回。生活中的辛酸苦辣与命运的不可抗拒在所难免的，只要深知这是生活的一部分才可以一步一步的走过来。个人其实对富贵其实是又爱又恨，爱是的到了朝枚之年能倘然、乐观的去面对一切，恨得是他一开始有那么好的一切，父母健在，女儿动人，爱妻宽容，却选择了挥霍祖上留下来的一切。活着，究竟是为什么？这个问题现代人也值得思考。不同的时代，不同的角度，或许会有不同的答案。多年之后，我想我对于这本书应该会是另外一种看法吧！</p>
<p>余华用每个人不同的命运遭遇，传达为了活着而活着的顽强精神。活着，就是希望！</p>
<blockquote>
<p>生活是属于每个人自己的感受，不属于任何别人的看法。—— 余华</p>
</blockquote>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile详解</title>
    <url>/2020/05/20/Dockerfile%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Dockerfile？"><a href="#Dockerfile？" class="headerlink" title="Dockerfile？"></a>Dockerfile？</h1><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h1 id="Dockerfile的指令"><a href="#Dockerfile的指令" class="headerlink" title="Dockerfile的指令"></a>Dockerfile的指令</h1><p>Dockerfile的十三个基本指令：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础镜像信息</td>
<td>FROM</td>
</tr>
<tr>
<td>维护者信息</td>
<td>MAINTAINER</td>
</tr>
<tr>
<td>镜像操作指令</td>
<td>RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME、ENV</td>
</tr>
<tr>
<td>容器启动时执行指令</td>
<td>CMD、ENTRYPOINT</td>
</tr>
</tbody>
</table>
<h2 id="FROM：指定基础镜像"><a href="#FROM：指定基础镜像" class="headerlink" title="FROM：指定基础镜像"></a>FROM：指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。基础镜像是必须指定的，并且必须是第一条指令。</p>
<p>如：指定centos作为基础镜像</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">FROM</span> centos</span><br></pre></td></tr></table></figure>
<h2 id="MAINTAINER：指定作者"><a href="#MAINTAINER：指定作者" class="headerlink" title="MAINTAINER：指定作者"></a>MAINTAINER：指定作者</h2><p>用来指定dockerfile的作者名称和邮箱，主要作用是为了标识软件的所有者是谁。<br>语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">MAINTAINER <span class="tag">&lt;<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">email</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MAINTAINER <span class="built_in">auto</span>r_xxx <span class="symbol">xxx@</span>qq.com</span><br></pre></td></tr></table></figure>
<h2 id="RUN：执行命令"><a href="#RUN：执行命令" class="headerlink" title="RUN：执行命令"></a>RUN：执行命令</h2><p>RUN指令在新镜像内部执行的命令，如：执行某些动作、安装系统软件、配置系统信息之类，</p>
<p>格式如下两种：</p>
<ol>
<li><p>shell格式：RUN&lt; command &gt; ，就像直接在命令行中输入的命令一样。</p>
</li>
<li><p>exec格式：RUN [“可执行文件”, “参数1”, “参数2”]</p>
</li>
</ol>
<p>如在新镜像中用yum方式安装nginx：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">RUN</span> [<span class="string">&quot;yum&quot;</span>,<span class="string">&quot;install&quot;</span>,<span class="string">&quot;nginx&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>注：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层.多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错,RUN书写时的换行符是\</p>
<h2 id="COPY：复制文件"><a href="#COPY：复制文件" class="headerlink" title="COPY：复制文件"></a>COPY：复制文件</h2><p>COPY命令用于将宿主机器上的的文件复制到镜像内，如果目的位置不存在，Docker会自动创建。但宿主机器用要复制的目录必须是和Dockerfile文件统计目录下。</p>
<p>格式：</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">COPY [--chown=<span class="attribute">&lt;user&gt;</span>:<span class="attribute">&lt;group&gt;</span>] <span class="attribute">&lt;源路径&gt;</span>... <span class="attribute">&lt;目标路径&gt;</span></span><br><span class="line">COPY [--chown=<span class="attribute">&lt;user&gt;</span>:<span class="attribute">&lt;group&gt;</span>] [&quot;<span class="attribute">&lt;源路径1&gt;</span>&quot;,... &quot;<span class="attribute">&lt;目标路径&gt;</span>&quot;]</span><br></pre></td></tr></table></figure>
<p>如把宿主机中的package.json文件复制到容器中/usr/src/app/目录下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span> <span class="keyword">package</span>.json <span class="regexp">/usr/</span>src<span class="regexp">/app/</span></span><br></pre></td></tr></table></figure>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h2 id="EXPOSE：暴露端口"><a href="#EXPOSE：暴露端口" class="headerlink" title="EXPOSE：暴露端口"></a>EXPOSE：暴露端口</h2><p>EXPOSE命名适用于设置容器对外映射的容器端口号，如tomcat容器内使用的端口8081，则用EXPOSE命令可以告诉外界该容器的8081端口对外，在构建镜像时<br>用docker run -p可以设置暴露的端口对宿主机器端口的映射。</p>
<p>语法：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">EXPOSE</span> &lt;端口<span class="number">1</span>&gt;<span class="meta"> [&lt;端口2&gt;...]</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">EXPOSE</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>EXPOSE 8081 其实等价于 docker run -p 8081 当需要把8081端口映射到宿主机中的某个端口（如8888）以便外界访问时，则可以用docker run -p 8888:8081</p>
<h2 id="WORKDIR：配置工作目录"><a href="#WORKDIR：配置工作目录" class="headerlink" title="WORKDIR：配置工作目录"></a>WORKDIR：配置工作目录</h2><p>WORKDIR命令是为RUN、CMD、ENTRYPOINT指令配置工作目录。其效果类似于Linux命名中的cd命令，用于目录的切换，但是和cd不一样的是：如果切换到的目录不存在，WORKDIR会为此创建目录。</p>
<p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> path</span></span><br></pre></td></tr></table></figure>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>ONBUILD用于配置当前所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。<br>意思就是：这个镜像创建后，如果其它镜像以这个镜像为基础，会先执行这个镜像的ONBUILD命令<br>格式：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ONBUILD</span><span class="meta"> [INSTRUCTION]</span></span><br></pre></td></tr></table></figure>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">USER <span class="attribute">&lt;用户名&gt;</span>[:<span class="attribute">&lt;用户组&gt;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ENV <span class="tag">&lt;<span class="name">key</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">ENV <span class="tag">&lt;<span class="name">key1</span>&gt;</span>=<span class="tag">&lt;<span class="name">value1</span>&gt;</span> <span class="tag">&lt;<span class="name">key2</span>&gt;</span>=<span class="tag">&lt;<span class="name">value2</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span></span><br></pre></td></tr></table></figure>
<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p>
<h2 id="ENTRYPOINT：容器启动执行命名"><a href="#ENTRYPOINT：容器启动执行命名" class="headerlink" title="ENTRYPOINT：容器启动执行命名"></a>ENTRYPOINT：容器启动执行命名</h2><p>ENTRYPOINT的作用和用法和CMD一模一样，但是ENTRYPOINT有和CMD有2处不一样：</p>
<ol>
<li>CMD的命令会被docker run的命令覆盖而ENTRYPOINT不会</li>
<li>CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖</li>
</ol>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>] <span class="comment"># 定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment"># 变参 </span></span></span><br></pre></td></tr></table></figure>
<p>1、不传参运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash">  nginx:<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">nginx -c <span class="regexp">/etc/</span>nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>2、传参运行</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ docker run  nginx:test -c <span class="regexp">/etc/</span>nginx/<span class="keyword">new</span>.conf</span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">nginx -c <span class="regexp">/etc/</span>nginx/<span class="keyword">new</span>.conf</span><br></pre></td></tr></table></figure>
<h1 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h1><p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在centos上安装nginx</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="comment">#标明著作人的名称和邮箱</span></span><br><span class="line">MAINTAINER jiabuli <span class="number">649917837</span>@qq.com</span><br><span class="line"><span class="comment">#测试一下网络环境</span></span><br><span class="line">RUN ping -c <span class="number">1</span> www.baidu.com</span><br><span class="line"><span class="comment">#安装nginx必要的一些软件</span></span><br><span class="line">RUN yum -y install gcc make pcre-devel zlib-devel tar zlib</span><br><span class="line"><span class="comment">#把nginx安装包复制到/usr/src/目录下</span></span><br><span class="line">ADD nginx-<span class="number">1.15</span>.<span class="number">8</span>.tar.gz <span class="regexp">/usr/</span>src/</span><br><span class="line"><span class="comment">#切换到/usr/src/nginx-1.15.8编译并且安装nginx</span></span><br><span class="line">RUN cd <span class="regexp">/usr/</span>src/nginx-<span class="number">1.15</span>.<span class="number">8</span> \</span><br><span class="line">    &amp;&amp; mkdir <span class="regexp">/usr/</span>local/nginx \</span><br><span class="line">    &amp;&amp; .<span class="regexp">/configure --prefix=/u</span>sr<span class="regexp">/local/</span>nginx &amp;&amp; make &amp;&amp; make install \</span><br><span class="line">    &amp;&amp; ln -s <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx /u</span>sr<span class="regexp">/local/</span>sbin/ \</span><br><span class="line">    &amp;&amp; nginx</span><br><span class="line"><span class="comment">#删除安装nginx安装目录</span></span><br><span class="line">RUN rm -rf <span class="regexp">/usr/</span>src/nginx-nginx-<span class="number">1.15</span>.<span class="number">8</span></span><br><span class="line"><span class="comment">#对外暴露80端口</span></span><br><span class="line">EXPOSE <span class="number">80</span></span><br><span class="line"><span class="comment">#启动nginx</span></span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="使用Dockerfile构建镜像"><a href="#使用Dockerfile构建镜像" class="headerlink" title="使用Dockerfile构建镜像"></a>使用Dockerfile构建镜像</h1><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol>
<li>上传安装包</li>
</ol>
<p>首先我们需要把要构建的软件安装包上传到服务器中，我们可以在服务器目录上创建一个专门的文件夹，如：/var/nginx_build,然后把从nginx官网下载的nginx-1.15.8.tar.gz安装包上传到这个目录里。</p>
<ol start="2">
<li>编写Dockerfile</li>
</ol>
<p>如何编写nginx的Dockerfile上面已经详细介绍，现在我们只需把编写好的Dockerfile上传到/var/nginx_build目录下，当然你也可以在服务器上直接编写Dockerfile，但是要记得一定保证Dockerfile文件和安装包在一个目录下。</p>
<ol start="3">
<li>运行构建命令构建</li>
</ol>
<p>docker build 命令用于使用 Dockerfile 创建镜像。</p>
<p>格式：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH |<span class="string"> URL </span>|<span class="string"> -</span></span><br></pre></td></tr></table></figure>
<p>OPTIONS有很多指令，下面列举几个常用的：</p>
<blockquote>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo入门实战</title>
    <url>/2019/04/19/Dubbo%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="Dubbo简介"><a href="#Dubbo简介" class="headerlink" title="Dubbo简介"></a>Dubbo简介</h2><p>Dubbo是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。</p>
<p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<p>文档：<a href="http://dubbo.apache.org/zh-cn/index.html">http://dubbo.apache.org/zh-cn/index.html</a></p>
<h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。<br>有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算环境（DCE）。</p>
<h2 id="Dubbo的作用"><a href="#Dubbo的作用" class="headerlink" title="Dubbo的作用"></a>Dubbo的作用</h2><ul>
<li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
</ul>
<h2 id="Dubbo的流程"><a href="#Dubbo的流程" class="headerlink" title="Dubbo的流程"></a>Dubbo的流程</h2><p><img src="/2019/04/19/Dubbo%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/9005929-b630c970a0b2e8ae.jpg" alt="9005929-b630c970a0b2e8ae.jpg"></p>
<p>如图：</p>
<p>0：start。服务容器container启动，加载提供者provider。</p>
<p>1：registry。服务提供者向dubbo的注册中心注册自己提供的服务。</p>
<p>2：subscribe注册。消费者服务启动的时候向注册中心订阅自己需要的服务。</p>
<p>3：notify通知。注册中心将消费者所需要的provider地址返回给consumer，如果有变更，注册中心将会基于长连接将变更数据推送给消费者。</p>
<p>4：invoke调用。服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>5：count。provider和consumer在内存中累计的调用次数和调用时间定时每分钟发送给监控中心。</p>
<h2 id="Zookeeper介绍"><a href="#Zookeeper介绍" class="headerlink" title="Zookeeper介绍"></a>Zookeeper介绍</h2><p>本Demo中的Dubbo注册中心采用的是Zookeeper。为什么采用Zookeeper呢？</p>
<p>Zookeeper是一个分布式的服务框架，是树型的目录服务的数据存储，能做到集群管理数据 ，这里能很好的作为Dubbo服务的注册中心。</p>
<p>Dubbo能与Zookeeper做到集群部署，当提供者出现断电等异常停机时，Zookeeper注册中心能自动删除提供者信息，当提供者重启时，能自动恢复注册数据，以及订阅请求。</p>
<h2 id="Dubbo实战"><a href="#Dubbo实战" class="headerlink" title="Dubbo实战"></a>Dubbo实战</h2><p><img src="/2019/04/19/Dubbo%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/微信截图_20190419135018.png" alt></p>
<p>服务提供者模块：dubbo-provider</p>
<p>消费者模块：dubbo-consumer</p>
<p>调用的服务接口共同的Api：dubbo-api</p>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p><img src="/2019/04/19/Dubbo%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/微信截图_20190419135540.png" alt><br>dubbo-provider模块下的application.properties配置如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span> = dubbo-provider</span><br><span class="line"><span class="attr">server.port</span> = <span class="number">9090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名）</span></span><br><span class="line"><span class="attr">dubbo.application.name</span> = dubbo-provider</span><br><span class="line"></span><br><span class="line"><span class="attr">demo.service.version</span> = <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo.protocol.name</span> = dubbo</span><br><span class="line"><span class="attr">dubbo.protocol.port</span> = <span class="number">20880</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定注册中心的位置</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span> = zookeeper://localhost:<span class="number">2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统一设置服务提供方的规则</span></span><br><span class="line"><span class="attr">dubbo.provider.timeout</span> = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>dubbo-consumer模块下的application.properties配置如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span> = dubbo-consumer</span><br><span class="line"><span class="attr">server.port</span> = <span class="number">9091</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名）</span></span><br><span class="line"><span class="attr">dubbo.application.name</span> = dubbo-consumer</span><br><span class="line"></span><br><span class="line"><span class="attr">demo.service.version</span> = <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo.protocol.name</span> = dubbo</span><br><span class="line"><span class="attr">dubbo.protocol.port</span> = <span class="number">20880</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定注册中心的位置</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span> = zookeeper://localhost:<span class="number">2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统一设置服务提供方的规则</span></span><br><span class="line"><span class="attr">dubbo.consumer.timeout</span> = <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>启动DubboProviderApplication和DubboConsumerApplication</p>
<p>访问：<a href="http://localhost:9091/sayHello/HelloWorld">http://localhost:9091/sayHello/HelloWorld</a><br><img src="/2019/04/19/Dubbo%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/微信截图_20190419140359.png" alt></p>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/LinXiaoBaiXCG/dubbo-demo">https://github.com/LinXiaoBaiXCG/dubbo-demo</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>接口幂等性的解决方案</title>
    <url>/2019/05/25/Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h1><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>
<p>总结：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的 。</p>
<h1 id="什么操作会破坏幂等性？"><a href="#什么操作会破坏幂等性？" class="headerlink" title="什么操作会破坏幂等性？"></a>什么操作会破坏幂等性？</h1><ol>
<li>前端重复提交数据</li>
<li>网络重发或系统bug重发</li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li><p>查询操作（安全且幂等）：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作。</p>
</li>
<li><p>删除操作（不安全但幂等）：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p>
</li>
<li><p>唯一索引：防止新增脏数据。</p>
<p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。</p>
<p>要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。</p>
</li>
<li><p>token机制：防止页面重复提交。</p>
<p>业务要求：页面的数据只能被点击提交一次。</p>
<p>发生原因： 由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。</p>
<p>解决办法： 当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到Redis当中，然后将Token发给客户端。<br>下次客户端提交请求时，Token会随着表单一起提交到服务器端。</p>
<p>服务器端第一次验证相同过后，会将Redis中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但Redis中Token已经改变了。</p>
</li>
<li><p>悲观锁</p>
<p>获取数据的时候加锁获取。select * from table_xxx where id=’xxx’ for update; </p>
<p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。</p>
</li>
<li><p>乐观锁——乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<ol>
<li>通过版本号实现update table_xxx set name=#name#,version=version+1 where version=#version#；</li>
<li>通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# &gt;= 0</li>
</ol>
</li>
<li><p>分布式锁</p>
<p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁。</p>
</li>
<li><p>select + insert：在并发不高的后台系统中，可以先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。</p>
</li>
<li><p>状态机幂等<br>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<p>注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>
</li>
<li><p>对外提供接口的api如何保证幂等<br>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。<br>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。</p>
<p>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在设计系统时，幂等性是首要考虑的问题，尤其是在涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题。 </p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo的高可用场景</title>
    <url>/2019/09/03/Dubbo%E9%AB%98%E5%8F%AF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="zookeeper宕机与dubbo直连"><a href="#zookeeper宕机与dubbo直连" class="headerlink" title="zookeeper宕机与dubbo直连"></a>zookeeper宕机与dubbo直连</h1><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露服务<br>原因：<br>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新的服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<h1 id="集群下dubbo负载均衡配置"><a href="#集群下dubbo负载均衡配置" class="headerlink" title="集群下dubbo负载均衡配置"></a>集群下dubbo负载均衡配置</h1><p>在集群负载均衡时，Dubbo提供了多种均衡策略，默认为random随机调用<br>负载均衡策略<br>RandomLoadBalance<br>RoundRobinLoadBalance<br>LeastActiveLoadBalance<br>ConsistentHashLoadBalance<br>详解：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a></p>
<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><p>什么是服务降级<br>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不出来或者换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p>
<p>向注册中心写入动态配置覆盖规则：<br><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">RegistryFactory registryFactory = </span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(RegistryFactory.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line">Registry registry = registryFactory.get<span class="constructor">Registry(URL.<span class="params">valueOf</span>(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>)</span>);</span><br><span class="line">registry.register(<span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span>value<span class="constructor">Of(<span class="string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=consumer_app&amp;mock=force:return+null&quot;</span>)</span>);</span><br></pre></td></tr></table></figure></p>
<p>mock=force:return+null<br>表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。<br>admin对消费者设置为屏蔽<br>mock=fail:return+null<br>表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。<br>admin对消费者设置为容错</p>
<p>dubbo 服务降级的真实含义：并不是对 provider 进行操作，而是告诉 consumer，调用服务时要做哪些动作。</p>
<h1 id="集群容错模式"><a href="#集群容错模式" class="headerlink" title="集群容错模式"></a>集群容错模式</h1><p>Dubbo 主要提供了这样几种容错方式：</p>
<ul>
<li>Failover Cluster - 失败自动切换</li>
<li>Failfast Cluster - 快速失败</li>
<li>Failsafe Cluster - 失败安全</li>
<li>Failback Cluster - 失败自动恢复</li>
<li>Forking Cluster - 并行调用多个服务提供者</li>
</ul>
<p>可整合Hystrix进行服务熔断</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch使用Logstash从MySQL中同步数据</title>
    <url>/2020/06/16/ElasticSearch%E4%BD%BF%E7%94%A8Logstash%E4%BB%8EMySQL%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p> 项目中的搜索功能需要使用ElasticSearch，现需使用Logstash来导入数据到ElasticSearch中。</p>
</blockquote>
<h1 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h1><ol>
<li>下载安装包并解压，亦可用Docker安装</li>
<li>进入装目录下的config文件夹中，修改elasticsearch.yml 文件，Docker安装进入容器内进行配置即可</li>
<li>修改的主要内容</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。</span></span><br><span class="line">cluster.name: my-es</span><br><span class="line"><span class="comment">#节点名称</span></span><br><span class="line">node.name: node-<span class="number">1</span></span><br><span class="line"><span class="comment">#设置索引数据的存储路径</span></span><br><span class="line">path.data: <span class="regexp">/usr/</span>local<span class="regexp">/elasticsearch/</span>data</span><br><span class="line"><span class="comment">#设置日志的存储路径</span></span><br><span class="line">path.logs: <span class="regexp">/usr/</span>local<span class="regexp">/elasticsearch/</span>logs</span><br><span class="line"><span class="comment">#设置当前的ip地址,通过指定相同网段的其他节点会加入该集群中</span></span><br><span class="line">network.host: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment">#设置对外服务的http端口</span></span><br><span class="line">http.port: <span class="number">9200</span></span><br><span class="line"><span class="comment">#设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;10.10.10.34:9200&quot;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h1><p>同样也是下载压缩到后解压即可，然后到解压目录执行</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/bin/</span>logstash -e</span><br></pre></td></tr></table></figure>
<p>查看日志能正常启动说明安装成功</p>
<h1 id="编写同步脚本"><a href="#编写同步脚本" class="headerlink" title="编写同步脚本"></a>编写同步脚本</h1><p>同步数据需要使用<code>logstash-input-jdbc</code>插件，在<code>logstash-6.1.1</code>以后已经默认支持 <code>logstash-input-jdbc</code>插件，所以不需要再单独安装了。</p>
<p>在安装目录下新建connector、script文件夹用于分别存放MySQL 的驱动文件和同步脚本</p>
<p>编写脚本</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      <span class="comment"># mysql 数据库链接</span></span><br><span class="line">      <span class="attr">jdbc_connection_string</span> =&gt; <span class="string">&quot;jdbc:mysql://host：port/database&quot;</span></span><br><span class="line">      <span class="comment"># 用户名和密码</span></span><br><span class="line">      <span class="attr">jdbc_user</span> =&gt; <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">      <span class="attr">jdbc_password</span> =&gt; <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">      <span class="comment"># MySQL的驱动文件地址</span></span><br><span class="line">      <span class="attr">jdbc_driver_library</span> =&gt; <span class="string">&quot;/usr/local/logstash-6.5.4/connector/mysql-connector-java-5.1.45.jar&quot;</span></span><br><span class="line">      <span class="comment"># 驱动类名</span></span><br><span class="line">      <span class="attr">jdbc_driver_class</span> =&gt; <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">      <span class="comment">#直接执行sql语句, sql_last_value 是内置的变量，表示上一次 sql 执行中 update_time 的值,and update_time&lt;now()解决临界点数据问题</span></span><br><span class="line">      <span class="attr">statement</span> =&gt;<span class="string">&quot;select * from blzq_article_v3 where is_show = 1 and update_time &gt;= :sql_last_value and update_time&lt;now()&quot;</span></span><br><span class="line">      <span class="comment"># 执行的sql 文件路径+名称</span></span><br><span class="line">      <span class="comment">#statement_filepath =&gt; &quot;/usr/local/logstash-6.5.4/xxxx&quot;</span></span><br><span class="line">      <span class="comment">#设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新</span></span><br><span class="line">      <span class="attr">schedule</span> =&gt; <span class="string">&quot;* * * * *&quot;</span></span><br><span class="line">      <span class="comment"># 索引类型</span></span><br><span class="line">      <span class="comment">#type =&gt; &quot;article&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 输出到elastsicearch</span></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">    	<span class="comment">#elasticsearch集群地址</span></span><br><span class="line">        <span class="attr">hosts</span> =&gt; [<span class="string">&quot;127.0.0.1:9200&quot;</span>,<span class="string">&quot;127.0.0.1:8200&quot;</span>,<span class="string">&quot;127.0.0.1:8000&quot;</span>]</span><br><span class="line">        <span class="comment"># 索引值，查询的时候会用到；需要先在elasticsearch中创建对应的mapping，也可以采用默认的mapping</span></span><br><span class="line">        <span class="attr">index</span> =&gt; <span class="string">&quot;article&quot;</span></span><br><span class="line">        <span class="attr">document_type</span> =&gt; <span class="string">&quot;article&quot;</span></span><br><span class="line">        <span class="comment">#指定插入elasticsearch文档ID，对应input中sql字段id</span></span><br><span class="line">        <span class="attr">document_id</span> =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">stdout</span> &#123;</span><br><span class="line">        <span class="attr">codec</span> =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用命令 <code>./bin/logstash -f ./script/mysql.conf</code> 执行导入脚本。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>使用Logstash同步数据环境的安装相对简单，主要是配置导入脚本</li>
<li>上面的导入配置脚本使用的是update_time方式的增量同步，该方式在数据库中物理删除是无法实时更新，可在项目中执行删除MySQL数据的时候同步删除ES中的数据</li>
<li>当对实时性和数据一致性有高要求时，可使用MQ进行同步</li>
<li>亦可使用ali的canal进行同步数据。项目地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术1-基本程序设计结构、对象和类</title>
    <url>/2019/03/16/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>读《Java核心技术1》记录知识点</p>
</blockquote>
<h1 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h1><ol>
<li><p>switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到<br>switch语句的结束处为止。如果没有相匹配的 case 标签， 而有 default 子句， 就执行这个子句。 </p>
</li>
<li><p>break和continue的区别？</p>
<p>用break语句可以使流程跳出switch语句体，也可以用break语句在循环结构终止本层循环体，从而提前结束本层循环。</p>
<p>continue语句的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环。</p>
</li>
<li><p>如果基本的整数和浮点数精度不能够满足需求， 那么可以使用 java.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。<br>Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。<br>使用静态的 valueOf 方法可以将普通的数值转换为大数值：<br>Biglnteger a = Biglnteger.valueOf(100);<br>遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数值类中的 add 和 multiply 方法。</p>
</li>
<li><p>数组是一种数据结构，用来存储同一类型值的集合。  </p>
</li>
<li><p>创建一个数字数组时，所有元素都初始化为 0。boolean 数组的元素会初始化为 false。 对象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。 </p>
</li>
<li><p>一旦创建了数组， 就不能再改变它的大小（尽管可以改变每一个数组元素）0 如果经常需要在运行过程中扩展数组的大小， 就应该使用另一种数据结构—数组列表（ array list)  </p>
</li>
<li><p>Arrays.toString(a), 返回一个包含数组元素的字符串 </p>
</li>
<li><p>要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法。<br>这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较<br>高的。 </p>
</li>
</ol>
<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><ol>
<li><p>类与类常见的关系：依赖、聚合、继承</p>
</li>
<li><p>类库设计者决定将保存时间与给时间点命名分开。所以标准 Java 类库分别包含了两个类：<br>一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。 </p>
</li>
<li><p>final实例域:可以将实例域定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。 </p>
</li>
<li><p>由于每个类对象都可以对公有域进行修改， 所以，最好不要将域设计为 public。然而， 公有常量（即 final 域）却没问题。</p>
</li>
<li><p>静态方法的另一种常见用途：工厂方法。为什么要使用工厂方法？</p>
<ul>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例<br>和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。 </li>
</ul>
</li>
<li><p>方法参数：按值调用 （call by value) 表示方法接收的是调用者提供的值。 而按引用调用 （ call by reference)表示方法接收的是调用者提供的变量地址。 一个方法可以修改传递引用所对应的变量值， 而不能修改传递值调用所对应的变量值 。</p>
</li>
<li><p>方法参数共有两种类型：<br>•基本数据类型（数字、布尔值）。<br>•对象引用。 </p>
</li>
<li><p>Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。 </li>
</ul>
</li>
<li><p>对象构造</p>
<p>9.1 重载：（类可以有多个构造器）如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution)。） </p>
<p>9.1.1 方法签名：要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名 。</p>
<p>​    返回类型不是方法签名的一部分。也就是说，不能有两个相同方法名，相同参数，但返回类型不同的方    法。</p>
<p>9.2 默认域初始化 ： 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、布尔值为 false、 对象引用为 null。 </p>
</li>
</ol>
<p>这是域与局部变量的主要不同点。 必须明确地初始化方法中的局部变量。 但是，如果没有初始化类中的域， 将会被自动初始化为默认值（ 0、 false 或 null )。 </p>
<p>9.3 无参数的构造器 ：如果在编写一个类时没有编写构造器， 那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是， 实例域中的数值型数据设置为 0、 布尔型数据设置为 false、 所有对象变量将设置为 null。 </p>
<p>如果类中提供了至少一个构造器， 但是没有提供无参数的构造器， 则在构造对象时如果没有提供参数就会被视为不合法。 </p>
<p>9.4 显式域初始化 : 通过重载类的构造器方法， 可以采用多种形式设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。 </p>
<p>9.5 调用另一个构造器 ：关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。<br>   如果构造器的第一个语句形如 this(…)， 这个构造器将调用同一个类的另一个构造器。 </p>
<p>9.6 初始化块:无论使用哪个构造器构造对象， id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。<br>   这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。 </p>
<pre><code>9.6.1 初始化数据域的方法： 
</code></pre><ol>
<li>在构造器中设置值 </li>
<li>在声明中赋值 </li>
<li>初始化块</li>
</ol>
<p>​    9.6.2 调用构造器的具体处理步骤： </p>
<ol>
<li>所有数据域被初始化为默认值（0、 false 或 null。) </li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。 </li>
<li>如果构造器第一行调用了第二个构造器， 则执行第二个构造器主体 。</li>
<li>执行这个构造器的主体。</li>
</ol>
<ol start="10">
<li>可以为任何一个类添加 finalize 方法。 finalize 方法将在垃圾回收器清除对象之前调用。<br>在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源， 这是因为很难知道这个方法什么时才能够调用。 </li>
<li>一个类可以使用所属包中的所有类， 以及其他包中的公有类 。</li>
<li>包的作用域：标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。 如果没有指定 public 或 private, 这 个 部分（类、方法或变量）可以被同一个包中的所有方法访问。 </li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中深拷贝和浅拷贝的理解和区别</title>
    <url>/2019/04/03/Java%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><p>Java中的对象拷贝(Object Copy)指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。举例说明：比如，对象A和对象B都属于类S，具有属性a和b。那么对对象A进行拷贝操作赋值给对象B就是：B.a=A.a;  B.b=A.b;</p>
<p>在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用现有对象的部分或全部数据。</p>
<p>Java中的对象拷贝主要分为：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)。</p>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。</p>
<p>浅拷贝是地址拷贝</p>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。</p>
<p>那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。</p>
<p>深拷贝是内容拷贝</p>
<h1 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h1><p>深拷贝会创建一个新的内存空间，拷贝的值是一样的，但是内存地址不一样。<br>浅拷贝只是拷贝指向原来对象的地址，使原对象的引用计数+1</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术1-并发</title>
    <url>/2019/03/20/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>读《Java核心技术1》记录知识点</p>
</blockquote>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ol>
<li>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程（ thread), 它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序（multithreaded)。  </li>
<li>多进程与多线程有哪些区别呢？ 本质的区别在于每个进程拥有自己的一整套变量， 而线程则共享数据。 这听起来似乎有些风险。然而，共享变量使线程之间的通信比进程之间的通信更有效、 更容易。 此外， 在有些操作系统中， 与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开销要小得多。  </li>
<li>调用 Threadsleep 不会创建一个新线程，sleep 是 Thread 类的静态方法，用于暂停当前线程的活动。  </li>
<li><p>Runnable 接口只有一个 run 方法  </p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2></li>
<li><p>当线程的 run 方法执行方法体中最后一条语句后， 并经由执行 return 语句返冋时， 或者出现了在方法中没有捕获的异常时，线程将终止。 在 Java 的早期版本中， 还有一个 stop方法， 其他线程可以调用它终止线程。但是， 这个方法现在已经被弃用了。  </p>
</li>
<li>没有可以强制线程终止的方法。然而， interrupt 方法可以用来请求终止线程。  </li>
<li>当对一个线程调用 interrupt 方法时，线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检査这个标志， 以判断线程是否被中断。<br>要想弄清中断状态是否被置位，首先调用静态的 Thread.currentThread 方法获得当前线程， 然后调用 islnterrupted 方法  </li>
<li>如果线程被阻塞， 就无法检测中断状态。这是产生 InterruptedExceptioii 异常的地方。当在一个被阻塞的线程（调用 sleep 或 wait ) 上调用 interrupt 方法时， 阻塞调用将会被Interrupted Exception 异常中断。</li>
</ol>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ol>
<li><p>线程可以有如下 6 种状态：</p>
<ul>
<li>New (新创建）：当用 new 操作符创建一个新线程时， 如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</li>
<li>Runnable (可运行）：一旦调用 start 方法，线程处于 runnable 状态。一个可运行的线桿可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。  </li>
</ul>
<p>一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。 当时间片用完，操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级  。<br>现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。<br>在具有多个处理器的机器上，每一个处理器运行一个线程， 可以有多个线程并行运行。当然， 如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。<br>记住，在任何给定时刻，二个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行。)</p>
<ul>
<li>Blocked (被阻塞）：当一个线程试图获取一个内部的对象锁（而不是 javiutiUoncurrent 库中的锁，) 而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。  </li>
<li>Waiting (等待）：当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。 在调用 Object.wait 方法或 Thread.join 方法， 或者是等待 java.util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。  </li>
<li>Timed waiting (计时等待）：有几个方法有一个超时参数。调用它们导致线程进人计时等待（timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有：<br>Thread.sleep 和 Object.wait、 Thread.join、 Lock.tryLock 以及 Condition.await 的计时版。  </li>
<li>Terminated (被终止）线程因如下两个原因之一而被终止：  </li>
</ul>
<ol>
<li>因为 run 方法正常退出而自然死亡。  </li>
<li>因为一个没有捕获的异常终止了 run 方法而意外死亡。  </li>
</ol>
</li>
</ol>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ol>
<li>线程的各种属性，其中包括：</li>
</ol>
<ul>
<li>线程优先级:在 Java 程序设计语言中，每一个线程有一个优先级。默认情况下， 一个线程继承它的父线程的优先级。可以用 setPriority 方法提高或降低任何一个线程的优先级。可以将优先级设置为在 MIN_PRIORITY (在 Thread 类中定义为 1 ) 与 MAX_PRIORITY (定义为 10 ) 之间的任何值。NORM_PRIORITY 被定义为 5。<br>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时， Java 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。<br>例如， Windows 有 7 个优先级别。一些 Java 优先级将映射到相同的操作系统优先级。在Oracle 为 Linux 提供的 Java 虚拟机中， 线程的优先级被忽略一所有线程具有相同的优先级。</li>
<li>守护线程：可以通过调用t.setDaemon(true);将线程转换为守护线程（daemon thread)。这样一个线程没有什么神奇。守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送“ 计时器嘀嗒” 信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时， 虚拟机就退出了，由于如果只剩下守护线程， 就没必要继续运行程序了。  </li>
<li>线程组以及处理未捕获异常的处理器：线程的 run方法不能抛出任何受查异常， 但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。但是，不需要任何 catch 子句来处理可以被传播的异常。相反， 就在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器。  </li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><ol>
<li><p>有两种机制防止代码块受并发访问的干扰。Java语言提供一个 synchronized 关键字达到这一目的，并且 Java SE 5.0 引入了 ReentrantLock 类。  </p>
</li>
<li><p>用 ReentrantLock 保护代码块的基本结构如下：<br>myLock.lock（）; // a ReentrantLock object</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">critical section</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">myLock.unlock()；<span class="comment">// make sure the lock is unlocked even if an exception is thrown</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>把解锁操作括在 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，<br>锁必须被释放。 否则， 其他线程将永远阻塞。</p>
</li>
<li><p>有关锁和条件的关键之处：  </p>
</li>
</ol>
<ul>
<li>锁用来保护代码片段， 任何时刻只能有一个线程执行被保护的代码。  </li>
<li>锁可以管理试图进入被保护代码段的线程。  </li>
<li>锁可以拥有一个或多个相关的条件对象。  </li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。  </li>
</ul>
<ol start="5">
<li><p>锁和条件是线程同步的强大工具，但是，严格地讲，它们不是面向对象的。多年来，研究人员努力寻找一种方法，可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。最成功的解决方案之一是监视器（monitor)  </p>
</li>
<li><p>监视器具有如下特性：</p>
<ul>
<li>监视器是只包含私有域的类。</li>
<li>每个监视器类的对象有一个相关的锁。</li>
<li>使用该锁对所有的方法进行加锁。换句话说，如果客户端调用 obj.method(), 那 么 obj对象的锁是在方法调用开始时自动获得， 并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作时， 没有其他线程能访问该域。</li>
<li>该锁可以有任意多个相关条件。</li>
</ul>
</li>
<li><p>volatile 关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为 volatile ,那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。  </p>
</li>
<li><p>线程在调用 lock 方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。 tryLock 方法试图申请一个锁， 在成功获得锁后返回 true, 否则， 立即返回false, 而且线程可以立即离开去做其他事情。  </p>
</li>
<li><p>lock 方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁， 那么， lock 方法就无法终止。<br>然而， 如果调用带有用超时参数的 tryLock, 那么如果线程在等待期间被中断，将抛出InterruptedException 异常。这是一个非常有用的特性，因为允许程序打破死锁。<br>也可以调用 locklnterruptibly 方法。它就相当于一个超时设为无限的 tryLock 方法。 </p>
</li>
<li><p>java.util.concurrent.locks 包 定 义 了 两 个 锁 类， 我 们 已 经 讨 论 的 ReentrantLock 类 和<br>ReentrantReadWriteLock 类。 如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话， 后者是十分有用的。在这种情况下， 允许对读者线程共享访问是合适的。当然， 写者线程依然必须是互斥访问的。   </p>
</li>
<li><p>为什么弃用 stop 和 suspend 方法?</p>
<p>初始的 Java 版本定义了一个 stop 方法用来终止一个线程， 以及一个 suspend 方法用来阻塞一个线程直至另一个线程调用 resume。stop 和 suspend 方法有一些共同点：都试图控制一个给定线程的行为。<br>stop、 suspend 和 resume 方法已经弃用。stop 方法天生就不安全，经验证明 suspend 方法会经常导致死锁。<br>首先来看看 stop 方法， 该方法终止所有未结束的方法， 包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。例如’假定 TransferThread在从一个账户向另一个账户转账的过程中被终止，钱款已经转出，却没有转人目标账户，现在银行对象就被破坏了。因为锁已经被释放，这种破坏会被其他尚未停止的线程观察到。<br>当线程要终止另一个线程时， 无法知道什么时候调用 stop 方法是安全的， 什么时候导致<br>对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程， 被中断的线程<br>会在安全的时候停止。</p>
<p>与 stop 不同，suspend 不会破坏对象。但是，如果用 suspend 挂起一个持有一个锁的线程， 那么，该锁在恢复之前是不可用的。 如果调用suspend 方法的线程试图获得同一个锁， 那么程序死锁： 被挂起的线程等着被恢复， 而将其挂起的线程等待获得锁。    </p>
</li>
</ol>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ol>
<li><p>对于许多线程问题， 可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插人元素， 消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。 例如， 考虑银行转账程序， 转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象。 另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部。因此不需要同步。（当然， 线程安全的队列类的实现者不能不考虑锁和条件，但是， 那是他们的问题而不是你的问题。）  </p>
</li>
<li><p>当试图向队列添加元素而队列已满， 或是想从队列移出元素而队列为空的时候， 阻塞队列（blocking queue ) 导致线程阻塞。在协调多个线程之间的合作时， 阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行得比第二个慢， 第二个线程集在等待结果时会阻塞。 如果第一个线程集运行得快， 它将等待第二个队列集赶上来。  </p>
</li>
<li><p>java.util.concurrent 包提供了阻塞队列的几个变种。 默认情况下， LinkedBlockingQueue的容量是没有上边界的，但是，也可以选择指定最大容量。LinkedBlockingDeque 是一个双端的版本。ArrayBlockingQueue 在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数， 则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它。</p>
<p>PriorityBlockingQueue 是一个带优先级的队列， 而不是先进先出队列。元素按照它们的优先级顺序被移出。该队列是没有容量上限，但是，如果队列是空的， 取元素的操作会阻塞。  </p>
</li>
</ol>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><ol>
<li>java.util.concurrent 包提供了映射、 有序集和队列的高效实现： ConcurrentHashMap、ConcurrentSkipListMap &gt; ConcurrentSkipListSet 和 ConcurrentLinkedQueue。这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。  </li>
<li>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合， 其中所有的修改线程对底层数组进行复制。 如果在集合上进行迭代的线程数超过修改线程数， 这样的安排是很有用的。当构建一个迭代器的时候， 它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组， 但是，集合的数组已经被替换了。因而，旧的迭代器拥有一致的（可能过时的）视图，访问它无须任何同步开销。</li>
</ol>
<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><ol>
<li>Runnable 封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。Callable 与 Runnable 类似， 但是有返回值。Callable 接口是一个参数化的类型， 只有一个方法 call。  </li>
<li>Future 保存异步计算的结果。可以启动一个计算，将 Future 对象交给某个线程，然后忘掉它。 Future 对象的所有者在结果计算好之后就可以获得它。  </li>
</ol>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><ol>
<li><p>构建一个新的线程是有一定代价的， 因为涉及与操作系统的交互。如果程序中创建了大量的生命期很短的线程，应该使用线程池（thread pool )。一个线程池中包含许多准备运行的空闲线程。 将 Runnable 对象交给线程池， 就会有一个线程调用 run 方法。 当 run 方法退出时， 线程不会死亡，而是在池中准备为下一个请求提供服务。   </p>
<p>构建一个新的线程是有一定代价的， 因为涉及与操作系统的交互。如果程序中创建了大<br>量的生命期很短的线程，应该使用线程池（thread pool )。一个线程池中包含许多准备运行的<br>空闲线程。 将 Runnable 对象交给线程池， 就会有一个线程调用 run 方法。 当 run 方法退出<br>时， 线程不会死亡，而是在池中准备为下一个请求提供服务。  </p>
</li>
<li><p>执行器 （ Executor) 类有许多静态工厂方法用来构建线程池。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术1-泛型程序设计、集合</title>
    <url>/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%81%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>读《Java核心技术1》记录知识点</p>
</blockquote>
<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><h2 id="为什么要使用泛型设计"><a href="#为什么要使用泛型设计" class="headerlink" title="为什么要使用泛型设计"></a>为什么要使用泛型设计</h2><ol>
<li>泛型正是我们需要的程序设计手段。使用泛型机制编写的程序代码要比那些杂乱地使用Object 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。 </li>
<li>泛型程序设计（Generic programming) 意味着编写的代码可以被很多不同类型的对象所重用。 </li>
<li>泛型提供了一个更好的解决方案： 类型参数 （ type parameters)。 ArrayList 类有一个类型参数用来指示元素的类型：<br>ArrayList<String> files = new ArrayList<String>():<br>这使得代码具有更好的可读性。人们一看就知道这个数组列表中包含的是 String 对象。   </String></String></li>
<li>类型参数的魅力在于：使得程序具有更好的可读性和安全性。  </li>
</ol>
<h2 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h2><ol>
<li>一个泛型类（generic class) 就是具有一个或多个类型变量的类。</li>
<li>类型变量使用大写形式，且比较短， 这是很常见的。在 Java 库中，使用变量 E 表示集合的元素类型， K 和 V 分别表示表的关键字与值的类型。 T ( 需要时还可以用临近的字母 U 和 S ) 表示“ 任意类型”。</li>
<li>泛型类可看作普通类的工厂。  </li>
</ol>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ol>
<li>一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符（这里是 public static) 后面，返回类型的前面。</li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当调用一个泛型方法时，在方法名前的尖括号中放人具体的类型 。</li>
</ol>
<h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><ol>
<li>虚拟机没有泛型类型对象—所有对象都属于普通类。  </li>
<li>无论何时定义一个泛型类型， 都自动提供了一个相应的原始类型 （ raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除（ erased) 类型变M , 并替换为限定类型 （无限定的变量用 Object)。</li>
<li>当程序调用泛型方法时， 如果擦除返回类型， 编译器插入强制类型转换。  </li>
<li>总之，需要记住有关 Java 泛型转换的事实：<ul>
<li>虚拟机中没有泛型，只有普通的类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成来保持多态。</li>
<li>为保持类型安全性，必要时插人强制类型转换。   </li>
</ul>
</li>
</ol>
<h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><ol>
<li>不能用基本类型实例化类型参数  </li>
<li>运行时类型查询只适用于原始类型  </li>
<li>Varargs 警告  </li>
<li>不能实例化类型变置  </li>
<li>不能创建参数化类型的数组</li>
<li>不能构造泛型数组</li>
<li>泛型类的静态上下文中类型变量无效  </li>
<li>不能抛出或捕获泛型类的实例</li>
<li>可以消除对受查异常的检查</li>
<li>注意擦除后的冲突</li>
</ol>
<h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><ol>
<li>泛型类可以扩展或实现其他的泛型类。就这一点而言，与普通的类没有什么区别。 例如， ArrayList<T> 类实现 List<T> 接口。这意味着， 一个 ArrayList<Manager> 可以被转换为一个 List<Manager>。  </Manager></Manager></T></T></li>
</ol>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><ol>
<li>通配符类型中， 允许类型参数变化。 例如， 通配符类型<br>Pair&lt;? extends Employee〉<br>表示任何泛型 Pair 类型， 它的类型参数是 Employee 的子类， 如 Pair<Manager>， 但不Pair<String>。</String></Manager></li>
<li>通配符限定与类型变量限定十分类似，但是，还有一个附加的能力， 即可以指定一个超类型限定 （supertypebound), 如下所亦：<br>? super Manager    </li>
</ol>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><ol>
<li>反射允许你在运行时分析任意的对象。 如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息， 因为它们会被擦除。  </li>
<li>可以使用反射 API 来确定：<ul>
<li>这个泛型方法有一个叫做 T 的类型参数。</li>
<li>这个类型参数有一个子类型限定， 其自身又是一个泛型类型。</li>
<li>这个限定类型有一个通配符参数。</li>
<li>这个通配符参数有一个超类型限定。</li>
<li>这个泛型方法有一个泛型数组参数。  </li>
</ul>
</li>
</ol>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><ol>
<li>队列接口指出可以在队列的尾部添加元素， 在队列的头部删除元素，并且可以査找队列中元素的个数。当需要收集对象， 并按照“ 先进先出” 的规则检索对象时就应该使用队列 。</li>
<li>队列通常有两种实现方式： 一种是使用循环数组； 另一种是使用链表 。</li>
<li>循环数组是一个有界集合， 即容量有限。如果程序中要收集的对象数量没有上限， 就最好使用链表来实现。  </li>
<li>在 Java 类库中，集合类的基本接口是 Collection 接口。  </li>
<li>编译器简单地将“ foreach” 循环翻译为带有迭代器的循环。<br>“ for each” 循环可以与任何实现了 Iterable 接口的对象一起工作， 这个接口只包含一个抽象方法。</li>
<li>Collection 接口扩展了 Iterable 接口。因此， 对于标准类库中的任何集合都可以使用“ foreach” 循环。   </li>
<li>元素被访问的顺序取决于集合类型。 如果对 ArrayList 进行迭代， 迭代器将从索引 0开始，每迭代一次，索引值加 1。 然而， 如果访问 HashSet 中的元素， 每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说，并不是什么问题。   </li>
<li>将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用 。</li>
<li>Iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该先看一下这个元素是很具有实际意义的。然而， 如果想要删除指定位置上的元素， 仍然需要越过这个元素。  </li>
<li>对 next 方法和 remove 方法的调用具有互相依赖性。如果调用 remove 之前没有调用 next 将是不合法的。 如果这样做， 将会抛出一个 IllegalStateException 异常。  </li>
<li>由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。  </li>
<li>集合有两个基本接口：Collection 和 Map。  </li>
<li>List 是一个有序集合（ or办 元 素 会 增 加 到 容 器 中 的 特 定 位 置。 可 以采用两种方式访问元素：使用迭代器访问， 或者使用一个整数索引来访问。后一种方法称为随机访问（random access), 因为这样可以按任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。   </li>
<li>Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（set) 的 add方法不允许增加重复的元素。要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。 hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。  </li>
</ol>
<h2 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h2><ol>
<li><p>数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是<br>数组中处于被删除元素之后的所有元素都要向数组的前端移动。 在数组中间的位置上插入一个元素也是如此。  </p>
</li>
<li><p>的数据结构一链表（ linked list) 解决了这个问题。尽管数组在连续的存储位置上存放对象引用， 但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在 Java 程序设计语言中， 所有链表实际上都是双向链接的(doubly linked)—即每个结点还存放着指向前驱结点的引用 。</p>
</li>
<li><p>从链表中间删除一个元素是一个很轻松的操作， 即需要更新被删除元素附近的链接 。</p>
</li>
<li><p>链 表 与 泛 型 集 合 之 间 有 一 个 重 要 的 区 别。 链 表 是 一 个 有 序 集 合（ ordered collection), 每个对象的位置十分重要。 LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的， 所以这种依赖于位置的 add 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。 集 （set ) 类型，其中的元素完全无序。 因此， 在 Iterator 接口中就没有add 方法。相反地，集合类库提供了子接口 Listlterator, 其 中 包 含 add 方 法 。</p>
</li>
<li><p>如果多次调用 add 方法， 将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。</p>
</li>
<li><p>可以使用 Listlterator 类从前后两个方向遍历链表中的元素， 并可以添加、 删除元素。   </p>
</li>
<li><p>为什么要优先使用链表呢？ 使用链表的唯一理由是尽可能地减少在列表中间插人或删除元素所付出的代价。 如果列表只有少数几个元素， 就完全可以使用 ArrayList。   </p>
</li>
<li><p>有一种众所周知的数据结构， 可以快速地査找所需要的对象， 这就是散列表（hash table )。散列表为每个对象计算一个整数， 称为散列码（hash code)。散列码是由对象的实例域产生的一个整数。更准确地说， 具有不同数据域的对象将产生不同的散列码。</p>
</li>
<li><p>自己实现的 hashCode方法应该与 equals 方法兼容，即如果 a_equals(b) 为 true, a 与 b 必须具有相同的散列码。  </p>
</li>
<li><p>在 Java 中， 散列表用链表数组实现。每个列表被称为桶 （ bucket)要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。 </p>
<p>例如， 如果某个对象的散列码为 76268, 并且有 128 个桶， 对象应该保存在第 108 号桶中（ 76268除以 128余 108 )。 或许会很幸运， 在这个桶中没有其他元素， 此时将元素直接插人到桶中就可以了。  </p>
</li>
<li><p>当然， 有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。这时， 需要用新对象与桶中的所有对象进行比较，査看这个对象是否已经存在。如果散列码是合理且随机分布的， 桶的数目也足够大， 需要比较的次数就会很少。  </p>
</li>
<li><p>在 JavaSE 8 中， 桶满时会从链表变为平衡二叉树。如果选择的散列函数不当， 会产生很多冲突， 或者如果有恶意代码试图在散列表中填充多个有相同散列码的值， 这样就能提高性能。  </p>
</li>
<li><p>如果想更多地控制散列表的运行性能， 就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。 如果要插入到散列表中的元素太多， 就会增加冲突的可能性， 降低运行性能。  </p>
</li>
<li><p>如果大致知道最终会有多少个元素要插人到散列表中， 就可以设置桶数。通常， 将桶数设置为预计元素个数的 75% ~ 150%。有些研究人员认为：尽管还没有确凿的证据，但最好将桶数设置为一个素数， 以防键的集聚。标准类库使用的桶数是 2 的幂， 默认值为 16 (为表大小提供的任何值都将被自动地转换为 2 的下一个幂 )。当然，并不是总能够知道需要存储多少个元素的， 也有可能最初的估计过低。 如果散列表太满， 就需要再散列 （rehashed)。 如果要对散列表再散列， 就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，. 然后丢弃原来的表。 装填因子（ load factor) 决定何时对散列表进行再散列。 例如， 如果装填因子为 0.75 (默认值，) 而表中超过 75%的位置已经填人元素， 这个表就会用双倍的桶数自动地进行再散列。对于大多数应用程序来说， 装填因子为0.75 是比较合理的。  </p>
</li>
<li><p>散列表可以用于实现几个重要的数据结构。 其中最简单的是 set 类型。set 是没有重复元素的元素集合。set 的 add 方法首先在集中查找要添加的对象， 如果不存在，就将这个对象添加进去。  </p>
</li>
<li><p>Java 集合类库提供了一个 HashSet 类，它实现了基于散列表的集。可以用 add 方法添加元素。contains方法已经被重新定义， 用来快速地查看是否某个元素已经出现在集中。它只在某个桶中査找元素，而不必查看集合中的所有元素。</p>
</li>
<li><p>TreeSet 类与散列集十分类似， 不过， 它比散列集有所改进。树集是一个有序集合( sorted collection) o 可以以任意顺序将元素插入到集合中。在对集合进行遍历时， 每个值将自动地按照排序后的顺序呈现。 </p>
</li>
<li><p>正如 TreeSet 类名所示， 排序是用树结构完成的（当前实现使用的是红黑树（red-black tree)）。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。  </p>
</li>
<li><p>队列可以让人们有效地在尾部添加一个元素， 在头部删除一个元素。有两个端头的队列， 即双端队列， 可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。在 Java SE 6 中引人了 Deque 接口， 并由 ArrayDeque 和LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</p>
</li>
<li><p>优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆（heap)。堆是一个可以自我调整的二叉树，对树执行添加 （ add) 和删除（remore) 操作， 可以让最小的元素移动到根，而不必花费时间对元素进行排序。  </p>
</li>
</ol>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ol>
<li>集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素， 需要有要查找元素的精确副本。这不是一种非常通用的査找方式。通常， 我们知道某些键的信息，并想要查找与之对应的元素。 映射（ map) 数据结构就是为此设计的。映射用来存放键 / 值对。如果提供了键， 就能够查找到值。</li>
<li>Java 类库为映射提供了两个通用的实现： HashMap 和 TreeMap 。这两个类都实现了 Map 接口。  </li>
<li>散列映射对键进行散列， 树映射用键的整体顺序对元素进行排序， 并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。</li>
<li>应该选择散列映射还是树映射呢？ 与集一样， 散列稍微快一些， 如果不需要按照排列顺序访问键， 就最好选择散列。  </li>
<li>键必须是唯一的。不能对同一个键存放两个值。 如果对同一个键两次调用 put 方法， 第二个值就会取代第一个值。实际上， put 将返回用这个键参数存储的上一个值。  </li>
<li>remove 方法用于从映射中删除给定键对应的元素。 size 方法用于返回映射中的元素数。  </li>
<li>集合框架不认为映射本身是一个集合。（其他数据结构框架认为映射是一个键 / 值对集合， 或者是由键索引的值集合。）不过， 可以得到映射的视图（ View )—这是实现了Collection 接口或某个子接口的对象。  </li>
<li>有 3 种视图： 键集、 值集合（不是一个集） 以及键 / 值对集。键和键 / 值对可以构成一个集， 因为映射中一个键只能有一个副本。  </li>
<li>LinkedHashSet 和 LinkedHashMap类用来记住插人元素项的顺序。这样就可以避免在散歹IJ表中的项从表面上看是随机排列的。当条目插入到表中时，就会并人到双向链表中  </li>
</ol>
<h2 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h2><ol>
<li>keySet 方法返回一个实现 Set接口的类对象， 这个类的方法对原映射进行操作。这种集合称为视图。  </li>
<li>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。  </li>
<li>Arrays.asList返回的对象不是 ArrayList。它是一个视图对象， 带有访问底层数组的 get 和 set方法。改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法）都会抛出一个Unsupported OperationException 异常。  </li>
<li>如果由多个线程访问集合，就必须确保集不会被意外地破坏。例如， 如果一个线程试图将元素添加到散列表中，同时另一个线程正在对散列表进行再散列，其结果将是灾难性的。类库的设计者使用视图机制来确保常规集合的线程安全， 而不是实现线程安全的集合类。例如， Collections 类的静态 synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的 Map 。</li>
<li>现在， 就可以由多线程访问 map 对象了。像 get 和 put 这类方法都是同步操作的， 即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成。  </li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li>泛型集合接口有一个很大的优点， 即算法只需要实现一次。</li>
<li>Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排序。  </li>
<li>对列表进行随机访问的效率很低。实际上， 可以使用归并排序对列表进行高效的排序。然而，Java 程序设计语言并不是这样实现的。它直接将所有元素转人一个数组， 对数组进行排序，然后，再将排序后的序列复制回列表。  </li>
<li>集合类库中使用的排序算法比快速排序要慢一些， 快速排序是通用排序算法的传统选择。但是， 归并排序有一个主要的优点：稳定， 即不需要交换相同的元素。 为什么要关注相同元素的顺序呢？ 下面是一种常见的情况。 假设有一个已经按照姓名排列的员工列表。现在，要按照工资再进行排序。 如果两个雇员的工资相等发生什么情况呢？ 如果采用稳定的排序算法， 将会保留按名字排列的顺序。换句话说， 排序的结果将会产生这样一个列表， 首先按照工资排序， 工资相同者再按照姓名排序。  </li>
<li>Collections 类有一个算法 shuffle, 其功能与排序刚好相反， 即随机地混排列表中元素的顺序。  </li>
<li>shuffle 方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。  </li>
<li>要想在数组中査找一个对象， 通常要依次访问数组中的每个元素，直到找到匹配的元素为止。然而， 如果数组是有序的， 就可以直接査看位于数组中间的元素， 看一看是否大于要查找的元素。如果是， 用同样的方法在数组的前半部分继续查找； 否则， 用同样的方法在数组的后半部分继续查找。这样就可以将查找范围缩减一半。一直用这种方式査找下去。  </li>
<li>Collections 类的 binarySearch方法实现了这个算法。 注意， 集合必须是排好序的， 否则算法将返回错误的答案。要想查找某个元素， 必须提供集合（这个集合要实现 List 接口， 下面还要更加详细地介绍这个问题）以及要查找的元素。 如果集合没有采用 Comparable 接口的compareTo 方法进行排序， 就还要提供一个比较器对象。  </li>
</ol>
<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><ol>
<li>Hashtable 类与 HashMap 类的作用一样，实际上，它们拥有相同的接口。与 Vector 类的方法一样。Hashtable 的方法也是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用 HashMap。如果需要并发访问， 则要使用 ConcurrentHashMap  </li>
<li>遗留集合使用 Enumeration 接口对元素序列进行遍历。 Enumeration 接口有两个方法， 即hasMoreElements 和 nextElement。 这两个方法与 Iterator 接口的 hasNext 方法和 next 方法十分类似。  </li>
<li>属性映射（property map) 是一个类型非常特殊的映射结构。它有下面 3 个特性：  </li>
</ol>
<ul>
<li>键与值都是字符串。  </li>
<li>表可以保存到一个文件中， 也可以从文件中加载。  </li>
<li>使用一个默认的辅助表。  </li>
</ul>
<ol start="4">
<li>实现属性映射的 Java 平台类称为 Properties。  </li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行时数据区域</title>
    <url>/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p> 读《深入理解Java虚拟机》记录</p>
<p> Java 虚拟机有自动内存管理机制，但如果出现内存泄漏和溢出方面的问题，排查错误、修正问题就必须要了解虚拟机是怎样使用内存的。</p>
</blockquote>
<h1 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h1><p>Java运行时数据区域在JDK8前后是有区别的：</p>
<p>下图是 JDK8 之后的 JVM 内存布局。</p>
<p><img src="/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/14923529-c0cbbccaa6858ca1.png" alt="14923529-c0cbbccaa6858ca1"></p>
<p>JDK8 之前的内存区域图如下:</p>
<p><img src="/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/14923529-b96312d95eb09d15.png" alt="14923529-b96312d95eb09d15"></p>
<blockquote>
<p>在HotSpot JVM中，方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <em>java.lang.OutOfMemoryError: PermGen</em> ，为此JVM开发者不得不对虚拟机做调优。</p>
<p>JDK7的HotSpot，已经把原本放在永久代的字符串常量（移到堆中）、静态变量移出，到了JDK8则完全废弃了永久代，取而代之的是<strong>（元空间）Metaspace</strong>，将JDK7中永久代还剩余的内容（主要是类型信息）全部移到了元空间中。</p>
<p>运行时常量池在元空间</p>
</blockquote>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里面，字节码解释器工作时候就是通过改变机器数起的值来选择下一条需要执行的字节码执行，分支、循环、跳转、异常处理等基础功能都需要依赖计数器完成。</p>
<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>在活动线程中，只有位千栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。</p>
<p><img src="/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/14923529-7a6d6e02c15fff2f.png" alt="14923529-7a6d6e02c15fff2f"></p>
<h3 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h3><p>局部变量表是存放方法参数和局部变量的区域。 局部变量没有准备阶段， 必须显式初始化。如果是非静态方法，<strong>则在 index[0] 位置上存储的是方法所属对象的实例引用</strong>，一个引用变量占 4 个字节，随后存储的是参数和局部变量。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变呈写回局部变量表的存储空间内。</p>
<p>虚拟机栈规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</p>
<h3 id="2-操作栈"><a href="#2-操作栈" class="headerlink" title="2. 操作栈"></a>2. 操作栈</h3><p>操作栈是个初始状态为空的桶式结构栈。在方法执行过程中， 会有各种指令往<br>栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎， 其中的栈指的就是操<br>作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。</p>
<p><strong>i++ 和 ++i 的区别：</strong></p>
<ol>
<li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li>
<li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li>
</ol>
<p>之前之所以说 i++ 不是原子操作，即使使用 volatile 修饰也不是线程安全，就是因为，可能 i 被从局部变量表（内存）取出，压入操作栈（寄存器），操作栈中自增，使用栈顶值更新局部变量表（寄存器更新写入内存），其中分为 3 步，volatile 保证可见性，保证每次从局部变量表读取的都是最新的值，但可能这 3 步可能被另一个线程的 3 步打断，产生数据互相覆盖问题，从而导致 i 的值比预期的小。</p>
<h3 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h3><p>每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p>
<h3 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h3><p>方法执行时有两种退出情况：</p>
<ol>
<li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；</li>
<li>异常退出。</li>
</ol>
<p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p>
<ol>
<li>返回值压入上层调用栈帧。</li>
<li>异常信息抛给能够处理的栈帧。</li>
<li>PC计数器指向方法调用后的下一条指令。</li>
</ol>
<h2 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p>
<p>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。垃圾收集行为在这个区域是比较少出现的，其内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<p><strong>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</strong></p>
<p>为什么要使用元空间取代永久代的实现？</p>
<ol>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>将 HotSpot 与 JRockit 合二为一。</li>
</ol>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。</p>
<p>在 JDK 1.4 中新加入了 NIO，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。</p>
<p><img src="/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/14923529-3d9e650ad915bc0e.png" alt="14923529-3d9e650ad915bc0e"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术1-继承、接口</title>
    <url>/2019/03/17/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1-%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
<p>读《Java核心技术1》记录知识点</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><ol>
<li><p>利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域， 以满足新的需求。这是 Java 程序设计中的一项核心技术。  </p>
</li>
<li><p>反射是指在程序运行期间发现更多的类及其属性的能力。 </p>
</li>
<li><p>可以使用特定的关键字 super调用父类的方法。</p>
</li>
<li><p>可以通过 super 实现对超类构造器的调用。使用super 调用构造器的语句必须是子类构造器的第一条语句。 </p>
</li>
<li><p>如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 )的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。  </p>
</li>
<li><p>一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为多态（ polymorphism)。<br>在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。 </p>
</li>
<li><p>在 Java 中， 不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征， 可以将它标记为 final </p>
</li>
<li><p>对于 final 域来说，构造对象之后就不允许改变它们的值了。 不过， 如果将一个类声明为 final， 只有其中的方法自动地成为 final,而不包括域。 </p>
</li>
<li><p>为了提高程序的清晰度， 包含一个或多个抽象方法的类本身必须被声明为抽象的。 </p>
</li>
<li><p>抽象方法之外，抽象类还可以包含具体数据和具体方法。 </p>
</li>
<li><p>类即使不含抽象方法，也可以将类声明为抽象类。<br>抽象类不能被实例化。也就是说， 如果将一个类声明为 abstract, 就不能创建这个类的对象 </p>
</li>
<li><p>归纳一下 Java 用于控制可见性的 4 个访问修饰符：<br>1 ) 仅对本类可见 private。<br>2 ) 对所有类可见 public。<br>3 ) 对本包和所有子类可见 protected。<br>4 ) 对本包可见—默认（很遗憾，) 不需要修饰符。</p>
</li>
</ol>
<h2 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h2><ol>
<li>Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。</li>
<li>在 Java 中， 只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的值都不是对象。 </li>
<li>Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。  </li>
<li>散列码（ hash code ) 是由对象导出的一个整型值。 散列码是没有规律的。如果 x 和 y 是两个不同的对象， x.hashCode( ) 与 y.hashCode( ) 基本上不会相同。</li>
<li>如果重新定义 equals方法， 就必须重新定义 hashCode 方法， 以便用户可以将对象插入到散列表中。</li>
</ol>
<h2 id="泛型数组列表（ArrayList）"><a href="#泛型数组列表（ArrayList）" class="headerlink" title="泛型数组列表（ArrayList）"></a>泛型数组列表（ArrayList）</h2><ol>
<li><p>ArrayList在添加或删除元素时， 具有自动调节数组容量的功能，而不需要为此编写任何代码。 </p>
</li>
<li><p>数组列表管理着对象引用的一个内部数组。最终， 数组的全部空间有可能被用尽。这就显现出数组列表的操作魅力： 如果调用 add 且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。 </p>
</li>
<li><p>如果已经清楚或能够估计出数组可能存储的元素数量， 就可以在填充数组之前调用<br>ensureCapacity方法：<br>staff.ensureCapacity(lOO);<br>这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100 次 add, 而不用重新分配空间。<br>另外，还可以把初始容量传递给 ArrayList 构造器：<br>ArrayList<Employee> staff = new ArrayListo(100) ; </Employee></p>
</li>
<li><p>一旦能够确认数组列表的大小不再发生变化， 就可以调用 trimToSize 方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。<br>一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时， 再调用 trimToSize。  </p>
</li>
<li><p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。 其原因是 ArrayList 类并不是 Java 程序设计语言的一部分；它只是一个由某些人编写且被放在标准库中的一个实用类。<br>使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜爱的 [ ] 语法格式。 </p>
</li>
<li><p>使用 list.set(i,x) 方法，它只能替换数组中已经存在的元素内容。 </p>
</li>
<li><p>没有泛型类时， 原始的 ArrayList 类提供的get方法别无选择只能返回Object, 因此，get方法的调用者必须对返回值进行类型转换：<br>Employee e = (Eiployee) staff.get(i); </p>
</li>
<li><p>原始的 ArrayList 存在一定的危险性。它的 add 和 set 方法允许接受任意类型的对象。对于下面这个调用<br>staff.set(i,”Harry Hacker”);<br>编译不会给出任何警告， 只有在检索对象并试图对它进行类型转换时， 才会发现有问题。如果使用 ArrayList<Employee>, 编译器就会检测到这个错误。 </Employee></p>
</li>
<li><p>对数组实施插人和删除元素的操作其效率比较低。对于小型数组来说， 这一点不必担心。但如果数组存储的元素数比较多， 又经常需要在中间位置插入、删除元素， 就应该考虑使用链表了。 </p>
</li>
<li><p>类型化与原始数组列表的兼容性问题：一旦能确保不会造成严重的后果， 可以用@SuppressWamings(“unchecked”) 标注来标记这个变量能够接受类型转换， 如下所示：<br>@SuppressWarnings (“unchecked”) </p>
<p>ArrayList<Employee> result =(ArrayList<Employee>) employeeDB.find(query); // yields another warning </Employee></Employee></p>
</li>
</ol>
<h2 id="对象的包装器与自动装箱"><a href="#对象的包装器与自动装箱" class="headerlink" title="对象的包装器与自动装箱"></a>对象的包装器与自动装箱</h2><ol>
<li><p>对象包装器 ：有时，需要将 int 这样的基本类型转换为对象。 所有的基本类型都有一个与之对应的类。例如，Integer 类对应基本类型 int。通常， 这些类称为包装器 （ wrapper ) 。</p>
<p>这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character 、 Void 和 Boolean (前6 个类派生于公共的超类 Number)。对象包装器类是不可变的，即一旦构造了包装器，就不<br>允许更改包装在其中的值。同时， 对象包装器类还是 final , 因此不能定义它们的子类。 </p>
</li>
<li><p>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成 ArrayList<int>。这里就用到了 Integer 对象包装器类。 我们可以声明一个 Integer对象的数组列表。</int></p>
</li>
<li><p>如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double, 再装箱为 Double  </p>
</li>
</ol>
<h2 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h2><ol>
<li><p>printf方法是这样定义的：<br>public class PrintStream<br>{<br>public PrintStream printf(String fmt , Object… args) { return format(fmt, args); }<br>}<br>这里的省略号 . . . 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 fmt参数之外）。</p>
<p>实际上，printf 方法接收两个参数，一个是格式字符串，另一个是 Object [] 数组 </p>
</li>
</ol>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ol>
<li><p>枚举类 ：在比较两个枚举类型的值时， 永远不需要调用 equals, 而直接使用“ = =” 就可以了。</p>
</li>
<li><p>所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。其中最有用的一个是 toString， 这个方法能够返回枚举常量名。 例如，Size.SMALL.toString( ) 将返回字符串“ SMALL”。 </p>
</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol>
<li>能够分析类能力的程序称为反射（ reflective )。 </li>
<li>反射机制可以用来： <ul>
<li>在运行时分析类的能力。 </li>
<li>在运行时查看对象， 例如， 编写一个 toString 方法供所有类使用。</li>
<li>实现通用的数组操作代码。</li>
<li>利用 Method 对象， 这个对象很像C++中的函数指针。 </li>
</ul>
</li>
<li>在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。 </li>
<li>可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class。</li>
<li>Object 类中的 getClass( ) 方法将会返回一个 Class 类型的实例。 </li>
<li>最常用的 Class 方法是 getName。 这个方法将返回类的名字。 </li>
<li>还可以调用静态方法 forName 获得类名对应的 Class 对象。 </li>
<li>虚拟机为每个类型管理一个 Class 对象。 因此， 可以利用= 运算符实现两个类对象比较的操作。 例如，<pre><code>if (e.getClass() == Employee.class)
</code></pre></li>
<li>还有一个很有用的方法 newlnstance( )， 可以用来动态地创建一个类的实例例如:<pre><code>e.getClass().newlnstance(); 
</code></pre></li>
<li>创建了一个与 e 具有相同类类型的实例。 newlnstance 方法调用默认的构造器 （没有参数的构造器）初始化新创建的对象。 如果这个类没有默认的构造器， 就会抛出一个异常 。将 forName 与 newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象 。</li>
<li>如果没有提供处理器， 程序就会终止，并在控制台上打印出一条信息， 其中给出了异常的类型。可能在前面已经看到过一些异常报告， 例如， 偶然使用了 null 引用或者数组越界等。 </li>
<li>异常有两种类型： 未检查异常和已检查异常。 对于已检查异常， 编译器将会检查是否提供了处理器。 然而， 有很多常见的异常， 例如， 访问 null 引用， 都属于未检查异常。 编译器不会査看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发生， 而不要将精力花在编写异常处理器上。 </li>
<li>如果类名不存在， 则将跳过 try 块中的剩余代码， 程序直接进人 catch 子句（这里，利用Throwable 类的 printStackTrace 方法打印出栈的轨迹。 Throwable 是 Exception 类的超类）。 如果 try 块中没有抛出任何异常， 那么会跳过 catch 子句的处理器代码。 </li>
<li>对于已检查异常， 只需要提供一个异常处理器。 可以很容易地发现会抛出已检査异常的方法。如果调用了一个抛出已检查异常的方法， 而又没有提供处理器， 编译器就会给出错误报告。</li>
<li><p>反射机制最重要的内容—检查类的结构。</p>
<p>  在 java.lang.reflect 包中有三个类 Field、 Method 和 Constructor 分别用于描述类的域、 方法和构造器。 这三个类都有一个叫做 getName 的方法， 用来返回项目的名称。 Field类有一个 getType 方法， 用来返回描述域所属类型的 Class 对象。<br>   Method 和 Constructor 类有能够报告参数类型的方法， Method 类还有一个可以报告返回类型的方法。</p>
<p>   这 三个类还有一个叫做 getModifiers 的方法， 它将返回一个整型数值， 用不同的位开关描述 public 和 static 这样的修饰符使用状况。另外， 还可以利用 java.lang.refleCt 包中的 Modifier类的静态方法分析getModifiers 返回的整型数值。 例如， 可以使用 Modifier 类中的 isPublic、 isPrivate 或 isFinal判断方法或构造器是否是 public、 private 或 final。 我们需要做的全部工作就是调用 Modifier类的相应方法， 并对返回的整型数值进行分析， 另外，还可以利用 Modifier.toString方法将修饰符打印出来。  </p>
</li>
<li><p>Class类中的 getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的public 域、 方法和构造器数组， 其中包括超类的公有成员。Class 类的 getDeclareFields、getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。 </p>
</li>
<li><p>反射机制的默认行为受限于 Java 的访问控制。然而， 如果一个 Java 程序没有受到安全管理器的控制， 就可以覆盖访问控制。 为了达到这个目的， 需要调用 Field、 Method 或Constructor 对象的 setAccessible 方法。 </p>
</li>
<li><p>setAccessible 方法是 AccessibleObject 类中的一个方法， 它是 Field、 Method 和 Constructor类的公共超类。这个特性是为调试、 持久存储和相似机制提供的。 </p>
</li>
<li><p>get 方法还有一个需要解决的问题。name 域是一个 String, 因此把它作为 Object 返回没有什么问题。但是， 假定我们想要查看 salary 域。它属于 double 类型， 而 Java 中数值类型不是对象。要想解决这个问题， 可以使用 Field 类中的 getDouble方法，也可以调用 get方法， 此时， 反射机制将会自动地将这个域值打包到相应的对象包装器中， 这里将打包成Double。</p>
</li>
<li><p>调用任意方法：在 C 和 C++ 中， 可以从函数指针执行任意函数。从表面上看， Java 没有提供方法指针，即将一个方法的存储地址传给另外一个方法， 以便第二个方法能够随后调用它。事实上，Java 的设计者曾说过：方法指针是很危险的，并且常常会带来隐患。 他们认为 Java 提供的接口（interface)是一种更好的解决方案。然而，反射机制允许你调用任意方法。 </p>
</li>
<li><p>在 Method 类中有一个 invoke 方法， 它允许调用包装在当前 Method 对象中的方法。 </p>
</li>
<li><p>继承的设计技巧</p>
<pre><code>1. 将公共操作和域放在超类 
2. 不要使用受保护的域 
3. 使用继承实现“ is-a” 关系 
4. 除非所有继承的方法都有意义， 否则不要使用继承 
5. 在覆盖方法时， 不要改变预期的行为 
6. 使用多态， 而非类型信息 
7. 不要过多地使用反射 
</code></pre></li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><ol>
<li>在 Java 程序设计语言中， 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</li>
<li>接口中的所有方法自动地属于 public。 因此， 在接口中声明方法时， 不必提供关键字public。</li>
<li>提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此， 可以将接口看成是没有实例域的抽象类 。</li>
<li>接口不是类，尤其不能使用 new 运算符实例化一个接口 。但却能声明接口的变量 。</li>
<li>接口变量必须弓I用实现了接口的类对象 。</li>
<li>同使用 instanceof检查一个对象是否属于某个特定类一样， 也可以使用instance 检查一个对象是否实现了某个特定的接口 。</li>
<li>与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。  </li>
<li>在接口中不能包含实例域或静态方法，但却可以包含常量。  </li>
<li>尽管每个类只能够拥有一个超类， 但却可以实现多个接口。这就为定义类的行为提供了极大的灵活性。  </li>
<li>为什么已经有抽象类了，Java还要引入接口？因为每个类只能继承一个类 ，但可以实现多个接口。</li>
<li>可以为接口方法提供一个默认实现。 必须用 default 修饰符标记这样一个方法。</li>
<li>默认实现可用于接口升级，是一种接口演化。<h2 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h2></li>
<li>回调（ callback) 是一种常见的程序设计模式。在这种模式中， 可以指出某个特定事件发生时应该采取的动作。<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2></li>
<li>lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。</li>
<li>Java 中的一种 lambda 表达式形式：参数， 箭头（-&gt;) 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {}中，并包含显式的 return 语句。</li>
<li>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样。</li>
<li>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。</li>
<li>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号。</li>
<li>无需指定lambda表达式的返回类型。<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2></li>
<li>内部类（inner class ) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因有以下三点：<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。</li>
<li>内部类可以对同一个包中的其他类隐藏起来。</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷。</li>
</ul>
</li>
<li>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</li>
<li>外围类对象的引用称为 outer。</li>
<li>只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</li>
<li>内部类中声明的所有静态域都必须是 final。</li>
<li>内部类不能有 static 方法。</li>
<li>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</li>
<li>与其他内部类相比较， 局部类还有一个优点。它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过， 那些局部变量必须事实上为 final。这说明， 它们一旦赋值就绝不会改变。</li>
<li>将局部内部类的使用再深人一步。 假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class)。</li>
<li>由于构造器的名字必须与类名相同， 而匿名类没有类名， 所以， 匿名类不能有构造器。取而代之的是，将构造器参数传递给超类 （ superclass) 构造器。尤其是在内部类实现接口的时候， 不能有任何构造参数。</li>
</ol>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ol>
<li>利用代理可以在运行时创建一个实现了一组给定接口的新类 : 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</li>
<li>何时使用代理</li>
</ol>
<p>假设有一个表示接口的 Class 对象（有可能只包含一个接口，) 它的确切类型在编译时无法知道。这确实有些难度。要想构造一个实现这些接口的类， 就需要使用 newlnstance 方法或反射找出这个类的构造器。但是， 不能实例化一个接口，需要在程序处于运行状态时定义一个新类。<br>为了解决这个问题， 有些程序将会生成代码；将这些代码放置在一个文件中；调用编译器；然后再加载结果类文件。很自然， 这样做的速度会比较慢，并且需要将编译器与程序放在一起。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：</p>
<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object 类中的全部方法， 例如， toString、 equals 等。</li>
</ul>
<ol start="3">
<li>不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（invocation handler)。调用处理器是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法：<br>Object invoke(Object proxy, Method method, Object[]  args)<br>无论何时调用代理对象的方法， 调用处理器的 invoke 方法都会被调用， 并向其传递Method 对象和原始的调用参数。 调用处理器必须给出处理调用的方式。</li>
<li>创建代理对象：<br>要想创建一个代理对象， 需要使用 Proxy 类的 newProxylnstance 方法。 这个方法有三个参数：<ul>
<li>一个类加栽器（class loader)。作为 Java 安全模型的一部分， 对于系统类和从因特网<br>上下载下来的类，可以使用不同的类加载器。目前，用 null 表示使用默认的类加载器。</li>
<li>一个 Class 对象数组， 每个元素都是需要实现的接口。</li>
<li>一个调用处理器。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-持久化</title>
    <url>/2019/04/20/MongoDB-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>Mongodb在1.8版本之后开始支持journal，就是我们常说的redo log，用于故障恢复和持久化。<br>MongoDB可以保证当服务器崩溃或服务器硬关机或硬盘故障时的数据完整性</p>
</blockquote>
<h1 id="MongoDB-Journaling"><a href="#MongoDB-Journaling" class="headerlink" title="MongoDB-Journaling"></a>MongoDB-Journaling</h1><h2 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h2><p>当执行写操作时，MongoDB创建一个journal来包含确切磁盘位置和改变的字节。因此，如果服务器突然崩溃， 可以在启动时对日志进行重放，从而重新执行哪些停机前没有刷新到磁盘的操作。 </p>
<p> 数据文件默认每60s刷盘一次。数据文件存放到/data/db/journal目录里。 </p>
<p> 数据库被正常关闭后，journal日志文件被刷盘，journal被清空。 </p>
<h2 id="批量提交"><a href="#批量提交" class="headerlink" title="批量提交"></a><strong>批量提交</strong></h2><p>Mongodb默认每隔100毫秒或者写入数据达到若干兆字节后，便会将这些操作写入到日志。即Mongodb不会在每次写入的时候都写入到日志，而是会成批量的提交更改。因此，在默认设置情况下，Mongodb不会丢失超过100毫秒的数据。<br><strong>因此，在Mongodb中存在丢失数据的可能。</strong> </p>
<h1 id="Journa工作原理"><a href="#Journa工作原理" class="headerlink" title="Journa工作原理"></a>Journa工作原理</h1><p>当系统启动时，mongodb会将数据文件映射到一块内存区域，称之为Shared view，在不开启journal的系统中，数据直接写入shared view，然后返回，系统每60s刷新这块内存到磁盘，这样，如果断电或down机，就会丢失很多内存中未持久化的数据。当系统开启了journal功能，系统会再映射一块内存区域供journal使用，称之为private view，mongodb默认每100ms刷新privateView到journal，也就是说，断电或宕机，有可能丢失这100ms数据，一般都是可以忍受的，如果不能忍受，那就用程序写log吧。这也是为什么开启journal后mongod使用的虚拟内存是之前的两倍。Mongodb的隔离级别是read_uncommitted，不管使用不使用journal，都是以内存中的数据为准，只不过，不开启journal，数据从shared view读取，开启journal，数据从private view读取。 </p>
<p>在开启journal的系统中，写操作从请求到写入磁盘共经历5个步骤，在serverStatus()中已经列出各个步骤消耗的时间。 </p>
<ol>
<li>Write to privateView </li>
<li><p>prepLogBuffer </p>
<p>Private view(PV) 中的数据并不是直接刷新到journal文件，而是通过一个中间内存块（journalbuffer，或者alogned buffer）一部分一部分的刷新到journal，这样可以提高并发。preplogbuffer即是将PV中的数据写入到aligned buffer中的过程。这个过程有两部分，basic write 操作和非 basic write操作（e.g.create file）。一次preplogbuffer是以一个commitJob为一个单位，可能会有很多个commitJob写入到aligned buffer，然后提交。一个commitJob中包含多个basic write 和非basic write 操作，basic write是存在Writeintent结构体中的，Writeintent记录了写操作的地址信息。非basic write 操作存在一个vector中。 </p>
</li>
<li><p>WritetoJournal </p>
<p>writetoJournal操作是将alignedbuffer刷新到JournalFile的过程。默认100ms刷新一次，由–journalCommitInterval 参数控制。writetoJournal会做一些checksum验证，将alignedbuffer进行压缩，然后将压缩过后的alignedbuffer写入到磁盘。写入磁盘后将删除已经满的Journal文件，更新lsn号到lsn文件。写操作到这一步就是安全的了，因为数据已经在磁盘上，如果使用getlasterror（j=true），这一步即可返回。 </p>
</li>
<li><p>WritetoDataFile </p>
<p>WritetoDataFile是将未压缩的aligned buffer写入到shared view的过程，然后由操作系统刷新到磁盘文件中。WritetoDataFile首先会对aligned buffer进行严格的验证，确保没有改变过，然后解析aligned buffer，通过memcpy函数拷贝到shareview </p>
</li>
<li><p>RemaptoPrivateView </p>
</li>
</ol>
<p>RemaptoprivateView会将持久化的数据重新映射到PV，以减小PV的大小，防止它不断扩大，按照源码上说，RemaptoprivateView会两秒钟重新映射一次，大约有1000个view，不是一次全做完，而是一部分一部分的做。由于读操作是读取PV，所以在映射完成之后会有短暂的时间读取磁盘。</p>
<p>经过这四步，一个写操作就完成了，journal提高了数据的安全性，并不像想象中的会丢数据，重要的是如何使用和维护。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis中$和#的区别</title>
    <url>/2019/06/16/MyBatis/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>动态SQL是Mybatis的主要特性之一，在mapper中定义的参数传到xml中之后，在查询之前Mybatis会对其进行动态解析。Mybatis为我们提供了两种支持动态SQL 的语法：#{} 以及 ${}。</p>
<p>#{}：占位符号，可以防止SQL注入（替换结果会增加单引号’’）</p>
<p>${}：SQL拼接符号（替换结果不会增加单引号’’，表名作为变量、like和order by时使用，存在sql注入问题，需手动代码中过滤）</p>
<p><strong>#{ }</strong></p>
<p>例如，Mapper.xml中如下的 sql 语句：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="type">name</span> = #&#123;<span class="type">name</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>动态解析为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="type">name</span> = ?; </span><br></pre></td></tr></table></figure>
<p>一个 #{ } 被解析为一个参数占位符 ? 。</p>
<p><strong>${ } </strong></p>
<p>例如，Mapper.xml中如下的 sql语句：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="type">name</span> = $&#123;<span class="type">name</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们传递的参数为 “Java” 时，上述 sql 的解析为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="type">name</span> = &quot;Java&quot;;</span><br></pre></td></tr></table></figure>
<p>预编译之前的 SQL 语句已经不包含变量了，完全已经是常量数据了。</p>
<p>综上所得， ${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>#{}是预编译处理，${}是字符串替换。</p>
<p>Mybatis在处理#{}时，会将SQL中的#{}替换为？，调用PreparedStatement的set方法来赋值。</p>
<p>Mybatis在处理${}时，就是把${}替换成变量的值。</p>
<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong>1、能使用 #{ } 的地方就用 #{ }</strong></p>
<ul>
<li>首先这是为了性能考虑的，相同的预编译 sql 可以重复利用。</li>
<li>其次，${ } 在预编译之前已经被变量替换了，这会存在 sql 注入问题。</li>
</ul>
<p>例如，如下的 sql：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> $&#123;tableName&#125; <span class="keyword">where</span> <span class="type">name</span> = #&#123;<span class="type">name</span>&#125;</span><br></pre></td></tr></table></figure>
<p>假如，我们的参数 tableName 为 user; delete user; –，那么 SQL 动态解析阶段之后，预编译之前的 sql 将变为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>; <span class="keyword">delete</span> <span class="keyword">user</span>; <span class="comment">-- where name = ?;</span></span><br></pre></td></tr></table></figure>
<p>– 之后的语句将作为注释，不起作用，因此本来的一条查询语句偷偷的包含了一个删除表数据的 SQL。</p>
<p><strong>2. 表名作为变量时，必须使用 ${ }</strong><br>这是因为，表名是字符串，使用 sql 占位符替换字符串时会带上单引号 ‘’，这会导致 sql 语法错误，例如：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> #&#123;tableName&#125; <span class="keyword">where</span> <span class="type">name</span> = #&#123;<span class="type">name</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>预编译之后的sql 变为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ? <span class="keyword">where</span> <span class="type">name</span> = ?;</span><br></pre></td></tr></table></figure>
<p>假设我们传入的参数为 tableName = “user” , name = “Java”，那么在占位符进行变量替换后，sql 语句变为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">&#x27;user&#x27;</span> <span class="keyword">where</span> <span class="type">name</span>=<span class="string">&#x27;Java&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上述 sql 语句是存在语法错误的</p>
<h2 id="SQL预编译"><a href="#SQL预编译" class="headerlink" title="SQL预编译"></a>SQL预编译</h2><p><strong>1. 定义：</strong><br>sql 预编译指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</p>
<p><strong>2. 为什么需要预编译</strong></p>
<ul>
<li>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。</li>
<li>预编译阶段可以优化 sql 的执行。预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</li>
<li>预编译语句对象可以重复利用。把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li>
<li>mybatis 默认情况下，将对所有的 sql 进行预编译。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中order by与limit一起使用存在的陷阱和解决方法</title>
    <url>/2021/03/01/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>近期，在使用MySQL时， SQL语句同时使用order by、limit时，发现数据有重复的问题。</p>
</blockquote>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>现在有一张user表，表结构及数据如下：</p>
<p><img src="/2021/03/01/MySQL/640.png" alt="640"></p>
<p><img src="/2021/03/01/MySQL/641.png" alt="641"></p>
<p>现在想根据创建时间升序查询user表，并且分页查询，每页2条，SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time limit pageNo,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>在执行查询过程中会发现：</p>
<ol>
<li>查询第一页数据时：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time limit <span class="number">0</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/01/MySQL/642.png" alt="642"></p>
<ol start="2">
<li>查询第四页数据时：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time limit <span class="number">6</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/01/MySQL/643.png" alt="643"></p>
<p>可以看出，查询过程中出现了相同的数据</p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p><img src="/2021/03/01/MySQL/644.png" alt="644"></p>
<p>上面官方文档里面有提到如果你将Limit row_count与order by混用，MySQL会找到排序的row_count行后立马返回，而不是排序整个查询结果再返回。如果是通过索引排序，会非常快；如果是文件排序，所有匹配查询的行（不带limit的）都会被选中，被选中的大多数或者全部会被排序，直到limit要求的row_count被找到了。如果limit要求的row_count行一旦被找到，MySQL就不会排序结果集中剩余的行了。</p>
<p>可以确认是用的文件排序，表确实也没有加额外的索引。所以我们可以确定这个SQL执行时是会找到limit要求的行后立马返回查询结果的。</p>
<p> <strong>这里我们查看下对应SQL的执行计划：</strong></p>
<p><img src="/2021/03/01/MySQL/645.png" alt="645"></p>
<p>可以确认是用的文件排序，表确实也没有加额外的索引。所以我们可以确定这个SQL执行时是会找到limit要求的行后立马返回查询结果的。</p>
<p><strong>不过就算它立马返回，为什么分页会不准呢？</strong></p>
<p>官方文档里面做了如下说明：</p>
<p><img src="/2021/03/01/MySQL/646.png" alt="646"></p>
<p>如果order by的字段有多个行都有相同的值，mysql是会随机的顺序返回查询结果的，具体依赖对应的执行计划。也就是说如果排序的列是无序的，那么排序的结果行的顺序也是不确定的。</p>
<p>基于这个我们就基本知道为什么分页会不准了，因为我们排序的字段是create_time，正好又有几个相同的值的行，在实际执行时返回结果对应的行的顺序是不确定的。对应上面的情况，第一页返回的name为8的数据行，可能正好排在前面，而第四页查询时name为8的数据行正好排在后面，所以第四页又出现了。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>官方给出了解决方案：</p>
<p><img src="/2021/03/01/MySQL/647.png" alt="647"></p>
<p>如果想在Limit存在或不存在的情况下，都保证排序结果相同，可以额外加一个排序条件。例如id字段是唯一的，可以考虑在排序字段中额外加个id排序去确保顺序稳定。</p>
<p>所以上面的情况下可以在SQL再添加个排序字段，比如fundflow的id字段，这样分页的问题就解决了。修改后的SQL可以像下面这样：SELECT * FROM <code>user</code> ORDER BY createtime,id LIMIT 6,2;</p>
<p>再次测试问题解决！！</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis中的方法和DAO接口方法是怎么绑定到一起的</title>
    <url>/2019/08/13/Mybatis%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8CDAO%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E8%B5%B7%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>在未理解代理前，一直有个疑问，Mybatis中DAO层接口没有写实现类，Mapper中的方法和DAO接口方法是怎么绑定到一起的，其内部是怎么实现的</p>
</blockquote>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>根据网上的一些知识点，讲一下原理:</p>
<p>Mybatis通过JDK的动态代理方式，在启动加载配置文件时，根据配置mapper的xml去生成Dao的实现。</p>
<p>session.getMapper()使用了代理，当调用一次此方法，都会产生一个代理class的instance,看看这个代理class的实现。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> MapperProxy implements InvocationHandler &#123;<span class="operator"> </span></span><br><span class="line"><span class="operator">... </span></span><br><span class="line"><span class="operator"></span>public static &lt;T&gt; T <span class="keyword">new</span><span class="constructor">MapperProxy(Class&lt;T&gt; <span class="params">mapperInterface</span>, SqlSession <span class="params">sqlSession</span>)</span> &#123; </span><br><span class="line">    ClassLoader classLoader = mapperInterface.get<span class="constructor">ClassLoader()</span>; </span><br><span class="line">    Class&lt;?&gt;<span class="literal">[]</span> interfaces = <span class="keyword">new</span> Class<span class="literal">[]</span>&#123;mapperInterface&#125;; </span><br><span class="line">    MapperProxy proxy = <span class="keyword">new</span> <span class="constructor">MapperProxy(<span class="params">sqlSession</span>)</span>; </span><br><span class="line">    return (T) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">classLoader</span>, <span class="params">interfaces</span>, <span class="params">proxy</span>)</span>; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123; </span><br><span class="line">    <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">OBJECT_METHODS</span>.</span></span>contains(<span class="keyword">method</span>.get<span class="constructor">Name()</span>)) &#123; </span><br><span class="line">      final Class&lt;?&gt; declaringInterface = find<span class="constructor">DeclaringInterface(<span class="params">proxy</span>, <span class="params">method</span>)</span>; </span><br><span class="line">      final MapperMethod mapperMethod = <span class="keyword">new</span> <span class="constructor">MapperMethod(<span class="params">declaringInterface</span>, <span class="params">method</span>, <span class="params">sqlSession</span>)</span>; </span><br><span class="line">      final Object result = mapperMethod.execute(args); </span><br><span class="line">      <span class="keyword">if</span> (result<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span><span class="keyword">method</span>.get<span class="constructor">ReturnType()</span>.is<span class="constructor">Primitive()</span>) &#123; </span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + <span class="params">method</span>.<span class="params">getName</span>()</span> + <span class="string">&quot;&#x27; (&quot;</span> + <span class="keyword">method</span>.get<span class="constructor">DeclaringClass()</span> + <span class="string">&quot;) attempted to return null from a method with a primitive return type (&quot;</span> + <span class="keyword">method</span>.get<span class="constructor">ReturnType()</span> + <span class="string">&quot;).&quot;</span>); </span><br><span class="line">      &#125; </span><br><span class="line">      return result; </span><br><span class="line">    &#125; </span><br><span class="line">    return null; </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>
<p>这里是用到了JDK的代理。 newMapperProxy()可以取得实现interfaces 的class的代理类的实例。</p>
<p>当执行interfaces中的方法的时候，会自动执行invoke()方法，其中public Object invoke(Object proxy, Method method, Object[] args)中 method参数就代表你要执行的方法.</p>
<p>MapperMethod类会使用method方法的methodName 和declaringInterface去取 sqlMapxml 取得对应的sql，也就是拿declaringInterface的类全名加上 sql-id</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security环境下CORS跨域失效问题</title>
    <url>/2019/05/12/Spring%20Security%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20CORS%20%E8%B7%A8%E5%9F%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>前后端分离项目中，后端已经配置对跨域支持，前端还是报请求跨域问题。</p>
</blockquote>
<h1 id="基于Spring-MVC正常配置跨域问题"><a href="#基于Spring-MVC正常配置跨域问题" class="headerlink" title="基于Spring MVC正常配置跨域问题"></a>基于Spring MVC正常配置跨域问题</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="keyword">class</span> WebMvcConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CorsConfiguration build<span class="constructor">Config()</span> &#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> <span class="constructor">CorsConfiguration()</span>;</span><br><span class="line">        corsConfiguration.add<span class="constructor">AllowedOrigin(<span class="string">&quot;*&quot;</span>)</span>;</span><br><span class="line">        corsConfiguration.add<span class="constructor">AllowedHeader(<span class="string">&quot;*&quot;</span>)</span>;</span><br><span class="line">        corsConfiguration.add<span class="constructor">AllowedMethod(<span class="string">&quot;*&quot;</span>)</span>;</span><br><span class="line">        corsConfiguration.add<span class="constructor">ExposedHeader(<span class="string">&quot;Authorization&quot;</span>)</span>;</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter cors<span class="constructor">Filter()</span> &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> <span class="constructor">UrlBasedCorsConfigurationSource()</span>;</span><br><span class="line">        source.register<span class="constructor">CorsConfiguration(<span class="string">&quot;/**&quot;</span>, <span class="params">buildConfig</span>()</span>);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">CorsFilter(<span class="params">source</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add<span class="constructor">CorsMappings(CorsRegistry <span class="params">registry</span>)</span> &#123;</span><br><span class="line">        registry.add<span class="constructor">Mapping(<span class="string">&quot;/**&quot;</span>)</span></span><br><span class="line">                .allowed<span class="constructor">Origins(<span class="string">&quot;*&quot;</span>)</span></span><br><span class="line">                .allowed<span class="constructor">Methods(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span></span><br><span class="line">                .allowed<span class="constructor">Headers(<span class="string">&quot;*&quot;</span>)</span></span><br><span class="line">                .max<span class="constructor">Age(3600)</span></span><br><span class="line">                .allow<span class="constructor">Credentials(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后前端控制他还是显示请求跨域问题，说明上面的配置失效了。</p>
<h1 id="跨域失效原因"><a href="#跨域失效原因" class="headerlink" title="跨域失效原因"></a>跨域失效原因</h1><p>启动 spring boot 项目，观察控制台打印的过滤器 chain 的顺序 cors filter 是在 spring security filter chain 之后。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.FilterRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;characterEncodingFilter&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.FilterRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;hiddenHttpMethodFilter&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.FilterRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;httpPutFormContentFilter&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.FilterRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;requestContextFilter&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.DelegatingFilterProxyRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;springSecurityFilterChain&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.FilterRegistrationBean - Mapping <span class="built_in">filter</span>: <span class="string">&#x27;corsFilter&#x27;</span> <span class="keyword">to</span>: [/*]</span><br><span class="line"><span class="keyword">o</span>.s.<span class="keyword">b</span>.<span class="keyword">w</span>.s.ServletRegistrationBean - Servlet dispatcherServlet mapped <span class="keyword">to</span> [/]</span><br></pre></td></tr></table></figure>
<p> 所以，问题很清晰了，问题在于 spring security 的 过滤器链，我们只需要将手动创建的跨域 filter 置于 spring security filter chain 之前即可。 </p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol>
<li>在Spring Security配置文件中configure方法开启跨域</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .cors().</span><br><span class="line">                and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                ……</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>手动实现跨域过滤器并将过滤器置于spring security filter chain之前</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: lcq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 手动生成过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019-05-11 16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityCorsFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">        res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        res.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS, DELETE, PUT&quot;</span>);</span><br><span class="line">        res.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">        res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Authorization, Content-Type, Accept, x-requested-with, Cache-Control&quot;</span>);</span><br><span class="line">        chain.doFilter(request, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">and</span><span class="literal">()</span>.add<span class="constructor">FilterBefore(<span class="params">new</span> WebSecurityCorsFilter()</span>, <span class="module-access"><span class="module"><span class="identifier">ChannelProcessingFilter</span>.</span></span><span class="keyword">class</span>) <span class="comment">// 添加前置过滤器，保证跨域的过滤器首先触发</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty核心组件介绍</title>
    <url>/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p> 理解Netty核心组件并使用netty</p>
</blockquote>
<h1 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>当客户端和服务端连接的时候会建立一个 Channel。Channel负责基本的 IO 操作，例如：bind（），connect（），read（），write（）等等。在Java的网络编程中，基础核心类是Socket，而Netty的Channel提供了一组API，极大地简化了直接与Socket进行操作的复杂性。</p>
<h2 id="EventLoop和EventLoopGoup"><a href="#EventLoop和EventLoopGoup" class="headerlink" title="EventLoop和EventLoopGoup"></a>EventLoop和EventLoopGoup</h2><p>有了 Channel 连接服务，让信息之间可以流动。如果服务发出的消息称作“出站”消息，服务接受的消息称作“入站”消息。那么消息的“出站”/“入站”就会产生事件（Event）。</p>
<p>例如：连接已激活；数据读取；用户事件；异常事件；打开链接；关闭链接等等。</p>
<p>有了数据，数据的流动产生事件，那么就有一个机制去监控和协调事件。</p>
<p>这个机制（组件）就是 EventLoop。在 Netty 中每个 Channel 都会被分配到一个 EventLoop。一个 EventLoop 可以服务于多个 Channel。</p>
<p>每个 EventLoop 会占用一个 Thread，同时这个 Thread 会处理 EventLoop 上面发生的所有 IO 操作和事件（Netty 4.0）。</p>
<p><img src="/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/netty核心组件介绍/1.jpg" alt></p>
<p>理解了 EventLoop，再来说 EventLoopGroup 就容易了，EventLoopGroup 是用来生成 EventLoop 的。</p>
<p>EventLoopGroup 要做的就是创建一个新的Channel，并且给它分配一个 EventLoop。</p>
<p><img src="/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/netty核心组件介绍/2.png" alt></p>
<p>可以看到。</p>
<ul>
<li>一个EventLoopGroup包含一个或多个EventLoop。</li>
<li>一个EventLoop在生命中周期绑定到一个Thread上。</li>
<li>EventLoop使用其对应的Thread处理IO事件。</li>
<li>一个Channel使用EventLoop进行注册。</li>
<li>一个EventLoop可被分配至一个或多个Channel。</li>
</ul>
<h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p>Netty中的所有IO操作都是异步的，不会立即返回，需要在稍后确定操作结果。因此Netty提供了ChannelFuture，其addListener方法可以注册一个ChannelFutureListener，当操作完成时，不管成功还是失败，均会被通知。ChannelFuture存储了之后执行的操作的结果并且无法预测操作何时被执行，提交至Channel的操作按照被唤醒的顺序被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过ChannelFuture 的 channel() 方法获取连接相关联的Channel </span></span><br><span class="line">    Channel channel = f.channel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过 ChannelFuture 接口的 sync()方法让异步的操作编程同步的。</span></span><br><span class="line">    <span class="comment">//bind()是异步的，但是，你可以通过 `sync()`方法将其变为同步。</span></span><br><span class="line">    ChannelFuture f = b.bind(port).sync();</span><br></pre></td></tr></table></figure>
<h2 id="ChannelHandler、ChannelPipeline和ChannelHandlerContext"><a href="#ChannelHandler、ChannelPipeline和ChannelHandlerContext" class="headerlink" title="ChannelHandler、ChannelPipeline和ChannelHandlerContext"></a>ChannelHandler、ChannelPipeline和ChannelHandlerContext</h2><p>如果说 EventLoop 是事件的通知者，那么 ChannelHandler 就是事件的处理者。</p>
<p>从应用开发者看来，ChannelHandler是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。</p>
<p>ChannelHandler的方法被网络事件触发，ChannelHandler可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。例如，其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据。</p>
<p>假设每次请求都会触发事件，而由 ChannelHandler 来处理这些事件，这个事件的处理顺序是由 ChannelPipeline 来决定的。</p>
<p>ChannelPipeline 为 ChannelHandler 链提供了容器。到 Channel 被创建的时候，会被 Netty 框架自动分配到 ChannelPipeline 上。</p>
<p>ChannelPipeline 保证 ChannelHandler 按照一定顺序处理事件，当事件触发以后，会将数据通过 ChannelPipeline 按照一定的顺序通过 ChannelHandler。</p>
<p>说白了，ChannelPipeline 是负责“排队”的。这里的“排队”是处理事件的顺序。</p>
<p>同时，ChannelPipeline 也可以添加或者删除 ChannelHandler，管理整个队列。</p>
<p><img src="/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/netty核心组件介绍/3.jpg" alt></p>
<p>如上图，ChannelPipeline 使 ChannelHandler 按照先后顺序排列，信息按照箭头所示方向流动并且被 ChannelHandler 处理。</p>
<p>说完了 ChannelPipeline 和 ChannelHandler，前者管理后者的排列顺序。那么它们之间的关联就由 ChannelHandlerContext 来表示了。</p>
<p>每当有 ChannelHandler 添加到 ChannelPipeline 时，同时会创建 ChannelHandlerContext 。</p>
<p>ChannelHandlerContext 的主要功能是管理 ChannelHandler 和 ChannelPipeline 的交互。</p>
<p>ChannelHandlerContext 参数贯穿 ChannelPipeline，将信息传递给每个 ChannelHandler，是个合格的“通讯员”。</p>
<p><img src="/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/netty核心组件介绍/7.png" alt></p>
<h2 id="Bytebuf（字节容器）"><a href="#Bytebuf（字节容器）" class="headerlink" title="Bytebuf（字节容器）"></a>Bytebuf（字节容器）</h2><p>网络通信最终都是通过字节流进行传输的。 ByteBuf 就是 Netty 提供的一个字节容器，其内部是一个字节数组。 当我们通过 Netty 传输数据的时候，就是通过 ByteBuf 进行的。</p>
<p>我们可以将 ByteBuf 看作是 Netty 对 Java NIO 提供了 ByteBuffer 字节容器的封装和抽象。</p>
<p>有很多小伙伴可能就要问了 ： 为什么不直接使用 Java NIO 提供的 ByteBuffer 呢？</p>
<p>因为 ByteBuffer 这个类使用起来过于复杂和繁琐。</p>
<h2 id="Bootstrap-和-ServerBootstrap（启动引导类）"><a href="#Bootstrap-和-ServerBootstrap（启动引导类）" class="headerlink" title="Bootstrap 和 ServerBootstrap（启动引导类）"></a>Bootstrap 和 ServerBootstrap（启动引导类）</h2><p>Bootstrap 的作用就是将 Netty 核心组件配置到程序中，并且让他们运行起来。</p>
<p>客户端引导 Bootstrap，主要有两个方法 bind（） 和 connect（）。Bootstrap 通过 bind（） 方法创建一个 Channel。</p>
<p>在 bind（） 之后，通过调用 connect（） 方法来创建 Channel 连接。</p>
<p>服务端引导 ServerBootstrap，与客户端不同的是在 Bind（） 方法之后会创建一个 ServerChannel，它不仅会创建新的 Channel 还会管理已经存在的 Channel。</p>
<p>服务端和客户端的引导存在两个区别：</p>
<ul>
<li>ServerBootstrap（服务端引导）绑定一个端口，用来监听客户端的连接请求。而 Bootstrap（客户端引导）只要知道服务端 IP 和 Port 建立连接就可以了。</li>
<li>Bootstrap（客户端引导）需要一个 EventLoopGroup，但是 ServerBootstrap（服务端引导）则需要两个 EventLoopGroup。因为服务器需要两组不同的 Channel。第一组 ServerChannel 自身监听本地端口的套接字。第二组用来监听客户端请求的套接字。</li>
</ul>
<h2 id="几个核心组件的关系"><a href="#几个核心组件的关系" class="headerlink" title="几个核心组件的关系"></a>几个核心组件的关系</h2><p><img src="/2021/05/17/Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/netty核心组件介绍/4.jpg" alt></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-常用命令及操作</title>
    <url>/2019/12/08/MongoDB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。<br>​ MongoDB 的官方网站地址是：<a href="http://www.mongodb.org/">http://www.mongodb.org/</a></p>
<h1 id="MongoDB的体系结构"><a href="#MongoDB的体系结构" class="headerlink" title="MongoDB的体系结构"></a>MongoDB的体系结构</h1><p>在MongoDB中基本的概念是数据库、集合、文档</p>
<p>MongoDB和MySQL概念对比</p>
<table>
<thead>
<tr>
<th>MySQL</th>
<th>MongoDB</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接,MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody>
</table>
<h1 id="MongoDB的数据类型"><a href="#MongoDB的数据类型" class="headerlink" title="MongoDB的数据类型"></a>MongoDB的数据类型</h1><ol>
<li>null：用于表示空值或者不存在的字段，{“x”:null}</li>
<li>布尔型：布尔类型有两个值true和false，{“x”:true}</li>
<li>数值：shell默认使用64为浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数）或NumberLong（8字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}</li>
<li>字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}</li>
<li>日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}</li>
<li>正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相同，{“x”:/[abc]/}</li>
<li>数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}</li>
<li>内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}</li>
<li>对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }</li>
<li>二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要将非utf-字符保存到数据库中，二进制数据是唯一的方式。</li>
<li>代码：查询和文档中可以包括任何JavaScript代码，{“x”:function(){/<em>…</em>/}} </li>
</ol>
<h1 id="MongoDB常用命令"><a href="#MongoDB常用命令" class="headerlink" title="MongoDB常用命令"></a>MongoDB常用命令</h1><ol>
<li><p>show dbs – 显示所有数据库</p>
</li>
<li><p>db – 显示当前数据库对象或集合</p>
</li>
<li><p>use DATABASE_NAME – 如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
</li>
<li><p>db.dropDatabase() –  删除数据库</p>
</li>
<li><p>db.COLLECTION_NAME.drop() – 删除集合</p>
</li>
<li>db.createCollection(name, options) – 创建集合（name: 要创建的集合名称；options: 可选参数, 指定有关内存大小及索引的选项）</li>
</ol>
<p>注意：创建集合后添加文档才算正式创建成功</p>
<ol start="7">
<li>show collections 或 show tables – 查看已有集合</li>
<li><p>db.COLLECTION_NAME.insert(document) 或 db.COLLECTION_NAME.save(document)  – 插入文档<br>注意：插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p>
</li>
<li><p>db.collection.update(<br>query,<br>update,<br>{<br>  upsert: boolean,<br>  multi: boolean,<br>  writeConcern: document<br>}） – 用于更新已存在的文档</p>
</li>
</ol>
<p>参数说明：</p>
<ul>
<li>query : update的查询条件，类似sql update查询内where后面的。</li>
<li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>
<li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li>writeConcern :可选，抛出异常的级别。</li>
</ul>
<ol start="10">
<li>db.collection.remove(<br>   query,<br>   justOne<br>) –删除文档</li>
</ol>
<p>参数说明：</p>
<ul>
<li>query :（可选）删除的文档的条件。</li>
<li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值</li>
<li>false，则删除所有匹配条件的文档。</li>
<li>writeConcern :（可选）抛出异常的级别。</li>
</ul>
<ol start="11">
<li>db.collection.find(query, projection) – 查询文档</li>
<li>条件操作符：</li>
</ol>
<ul>
<li>(&gt;) 大于 - $gt</li>
<li>(&lt;) 小于 - $lt</li>
<li>(&gt;=) 大于等于 - $gte</li>
<li>(&lt;= ) 小于等于 - $lte</li>
</ul>
<ol start="13">
<li>db.COLLECTION_NAME.find().limit(NUMBER) – 读取指定数量的数据记录，该参数指定从MongoDB中读取的记录条数。</li>
<li>db.COLLECTION_NAME.find().sort({KEY:1}) – 使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</li>
<li>db.COLLECTION_NAME.count() – 统计记录</li>
<li>模糊查询：MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：/模糊查询字符串/</li>
<li>包含与不包含：包含使用$in操作符。不包含使用$nin操作符。</li>
<li>条件连接：$and操作符将条件进行关联</li>
<li>列值自增：对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中事务的七种传播机制和四个隔离级别</title>
    <url>/2019/06/28/Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%9B%9B%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。</p>
</blockquote>
<h1 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h1><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p>
<h1 id="Spring中事务的七种传播机制"><a href="#Spring中事务的七种传播机制" class="headerlink" title="Spring中事务的七种传播机制"></a>Spring中事务的七种传播机制</h1><table>
<thead>
<tr>
<th>传播机制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED（默认）</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody>
</table>
<p>注：理解每个单词意思即可大致理解每种传播机制</p>
<h1 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h1><h2 id="事务并发引起的三种情况"><a href="#事务并发引起的三种情况" class="headerlink" title="事务并发引起的三种情况"></a>事务并发引起的三种情况</h2><ol>
<li><strong>脏读（DirtyReads）</strong> ：一个事务正在对数据进行更新操作，但是更新还未提交，另一个事务这时也来操作这组数据，并且读取了前一个事务还未提交的数据，而前一个事务如果操作失败进行了回滚，后一个事务读取的就是错误数据，这样就造成了脏读。</li>
<li><strong>不可重复读（Non-Repeatable Reads）</strong> ：一个事务多次读取同一数据，在该事务还未结束时，另一个事务也对该数据进行了操作，而且在第一个事务两次次读取之间，第二个事务对数据进行了更新，那么第一个事务前后两次读取到的数据是不同的，这样就造成了不可重复读。</li>
<li><strong>幻读（Phantom Reads）</strong>：第一个数据正在查询符合某一条件的数据，这时，另一个事务又插入了一条符合条件的数据，第一个事务在第二次查询符合同一条件的数据时，发现多了一条前一次查询时没有的数据，仿佛幻觉一样，这就是幻像读。</li>
</ol>
<h2 id="非重复度和幻像读的区别"><a href="#非重复度和幻像读的区别" class="headerlink" title="非重复度和幻像读的区别"></a>非重复度和幻像读的区别</h2><p>非重复读是指同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。</p>
<p>幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读。</p>
<p>表面上看，区别就在于非重复读能看见其他事务提交的修改和删除，而幻像能看见其他事务提交的插入。 </p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻 读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ_UNCOMMITTED （读未提交）</td>
<td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>READ_COMMITTED （读已提交）</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>REPEATABLE_READ （可重复读）</td>
<td>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p>注：MySQL的默认隔离级别是可重复读，Oracle的默认隔离级别是读已提交。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识总结</title>
    <url>/2019/04/07/Redis%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>高性能Key-Value服务器</li>
<li>支持多种数据结构</li>
<li>功能丰富</li>
<li>高可用分布式支持</li>
</ol>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>官方：10W OPS<br>数据存在内存<br>使用C语言编写<br>单线程模型</p>
<h2 id="持久化（断电不丢数据）"><a href="#持久化（断电不丢数据）" class="headerlink" title="持久化（断电不丢数据）"></a>持久化（断电不丢数据）</h2><p>对数据更新将异步地保存的磁盘上</p>
<h2 id="支持多种数据结构"><a href="#支持多种数据结构" class="headerlink" title="支持多种数据结构"></a>支持多种数据结构</h2><p>支持字符串、哈希、链表、集合、有序集合<br>新版本支持位图（BitMaps）<br>HyperLogLog：超小内存唯一值计数<br>GEO:地理信息定位</p>
<h2 id="支持多种编程语言"><a href="#支持多种编程语言" class="headerlink" title="支持多种编程语言"></a>支持多种编程语言</h2><p>java<br>php<br>lua</p>
<h2 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h2><p>发布订阅<br>事务<br>Lua脚本<br>pipeline</p>
<h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>源码少（带着问题看代码）<br>不依赖外部库</p>
<h2 id="主从复制（重点）"><a href="#主从复制（重点）" class="headerlink" title="主从复制（重点）"></a>主从复制（重点）</h2><p>从服务器复制到主服务器</p>
<h2 id="高可用、分布式"><a href="#高可用、分布式" class="headerlink" title="高可用、分布式"></a>高可用、分布式</h2><p>高可用—-Redis-Sentinel  支持高可用<br>分布式—-Redis-Cluster 支持分布式</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>缓存系统<br>提高响应速度</li>
<li>计数器<br>利用自增incr、decr可以实现计数器<br>转发数、评论数（微博）</li>
<li>消息队列系统<br>利用pub、sub模式发布订阅消息系统</li>
<li>排行榜<br>利用有序集合zset进行排序，得出排行榜</li>
<li>社交网络</li>
<li>实时系统  </li>
<li>限流</li>
</ul>
<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><ul>
<li>生产环境选择配置启动</li>
<li>单机多实例配置文件可以用端口区分开</li>
</ul>
<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><p>daemonize:是否是守护进程（no/yes）  建议yes<br>port:Redis对外端口<br>logfile:Redis日志系统<br>dir:Redis工作目录</p>
<h1 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h1><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><ul>
<li>keys(O(n)级：一般不在生产环境使用)</li>
<li>dbsize（O(1)级:计算key大小）</li>
<li>exists key（检查key是否存在1为存在2为不存在）</li>
<li>del key [key …]</li>
<li>expire key seconds</li>
<li>type key</li>
</ul>
<h2 id="Redis使用单线程还这么快？"><a href="#Redis使用单线程还这么快？" class="headerlink" title="Redis使用单线程还这么快？"></a>Redis使用单线程还这么快？</h2><ol>
<li>纯内存</li>
<li>非阻塞IO（使用epoll模型）</li>
<li>避免线程切换和竞态消耗</li>
</ol>
<h2 id="set-setnx-setxx"><a href="#set-setnx-setxx" class="headerlink" title="set setnx setxx"></a>set setnx setxx</h2><p>set key value:不管key是否存在，都设置<br>setnx key value:key不存在，才设置(可看做添加操作)<br>set key value xx :key存在，才设置(可看做编辑操作)</p>
<h1 id="Redis的扩展"><a href="#Redis的扩展" class="headerlink" title="Redis的扩展"></a>Redis的扩展</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><ul>
<li>生命周期<br>客户端发送命令到服务端，此时服务端有多条命令在执行，因为redis是单线程的，所以得排队等待执行命令，等待过程中会消耗一定是时间，最后返回结果</li>
<li>说明</li>
</ul>
<ol>
<li>慢查询发生在第三阶段（执行命令，例如：key *）</li>
<li>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</li>
</ol>
<ul>
<li>配置-slowlog-max-len = 128（支持动态配置）</li>
</ul>
<ol>
<li>先进先出队列</li>
<li>固定长度</li>
<li>保存在内存中</li>
</ol>
<ul>
<li>配置-slowlog-log-slower-than = 10000（支持动态配置）</li>
</ul>
<ol>
<li>慢查询阈值（单位：微秒）</li>
<li>slowlog-log-slower-than=0，记录所有命令</li>
<li>slowlog-log-slower-than&lt;0，不记录命令</li>
</ol>
<h2 id="执行批量命令时，可使用pipeline4-3"><a href="#执行批量命令时，可使用pipeline4-3" class="headerlink" title="执行批量命令时，可使用pipeline4.3"></a>执行批量命令时，可使用pipeline4.3</h2><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>角色：发布者  订阅者  频道</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>redis所有数据保存在内存中，对数据的更新将异步地保存在磁盘上。</p>
<h2 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h2><ul>
<li>快照</li>
</ul>
<ol>
<li>MySQL Dump</li>
<li>Redis RDB</li>
</ol>
<ul>
<li>写日志</li>
</ul>
<ol>
<li>MySQL Binlog</li>
<li>Hbase HLog</li>
<li>Redis AOF</li>
</ol>
<h2 id="Redis-RDB"><a href="#Redis-RDB" class="headerlink" title="Redis RDB"></a>Redis RDB</h2><p>RDB:redis创建RDB文件（二进制）选在硬盘中，类似备份</p>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ol>
<li>sava（同步）<br>介绍：执行sava命令会创建RDB文件（二进制）<br>缺点：会造成阻塞<br>注意：会覆盖旧的RDB文件<br>复杂度：O(N)</li>
<li>bgsava（异步）<br>介绍：执行bgsava命令，redis会fork（）redis的子进程，由子进程去创建RDB文件</li>
<li>自动<br>通过配置自动生成RDB</li>
</ol>
<ul>
<li>方式</li>
</ul>
<ol>
<li>全量复制</li>
<li>debug reload</li>
<li>shutdown</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>耗时耗性能</p>
<h3 id="sava和bgsava的区别"><a href="#sava和bgsava的区别" class="headerlink" title="sava和bgsava的区别"></a>sava和bgsava的区别</h3><table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fork）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork，消耗内存</td>
</tr>
</tbody>
</table>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>日志原理</p>
<h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><ol>
<li>always<br>redis写命令刷新的缓冲区，然后再每条命令fsync到硬盘上</li>
<li>everysec<br>redis写命令刷新的缓冲区，然后再每秒把缓冲区fsync到硬盘上</li>
<li>no<br>由操作系统决定</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th>命令</th>
<th>always</th>
<th>everysec</th>
<th>no</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>不丢失数据</td>
<td>每秒一次fsync丢一秒数据</td>
<td>不用管</td>
</tr>
<tr>
<td>缺点</td>
<td>IO开销较大，一般SATA盘只有几百TPS</td>
<td>丢一秒数据</td>
<td>不可控</td>
</tr>
</tbody>
</table>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>减少硬盘占用量</li>
<li>加速恢复速度</li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p>bgrewriteaof命令<br> fork子进程进行AOF重写</p>
</li>
<li><p>AOF重写配置</p>
</li>
</ol>
<ul>
<li>配置</li>
</ul>
<table>
<thead>
<tr>
<th>配置名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto-aof-rewrite-min-size</td>
<td>AOF文件重写需要的尺寸</td>
</tr>
<tr>
<td>auto-aof-rewrite-percentage</td>
<td>AOF文件增长率</td>
</tr>
</tbody>
</table>
<ul>
<li>统计</li>
</ul>
<table>
<thead>
<tr>
<th>统计名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>aof_current_size</td>
<td>AOF当前尺寸（单位：字节）</td>
</tr>
<tr>
<td>aof_base_size</td>
<td>AOF上次启动和重写的尺寸（单位：字节）</td>
</tr>
</tbody>
</table>
<h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="/2019/04/07/Redis%E8%A7%A3%E8%AF%BB/5b71bb0dd01ff7917aaaba10cb69041.jpg" alt="AOF重写流程图"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>appendonly     yes</p>
<h2 id="两种持久化的比较和选择"><a href="#两种持久化的比较和选择" class="headerlink" title="两种持久化的比较和选择"></a>两种持久化的比较和选择</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody>
</table>
<h3 id="RDB最佳策略"><a href="#RDB最佳策略" class="headerlink" title="RDB最佳策略"></a>RDB最佳策略</h3><p>建议关闭<br>集中管理<br>主从，从开</p>
<h3 id="AOF最佳策略"><a href="#AOF最佳策略" class="headerlink" title="AOF最佳策略"></a>AOF最佳策略</h3><p>建议开<br>AOF集中管理<br>建议每秒保存</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>数据副本<br>扩展读性能<br>一个master可以有多个slave<br>一个slave只能有一个master<br>数据是单向的</p>
<h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><h3 id="slaveof命令（异步）"><a href="#slaveof命令（异步）" class="headerlink" title="slaveof命令（异步）"></a>slaveof命令（异步）</h3><p>例如：slaveof 127.0.0.1 6379  返回OK则复制成功<br>取消复制：slaveof no one</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>slaveof ip port<br>从节点只读：slave-read-only yes</p>
<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th>方式</th>
<th>命令</th>
<th>配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>无需重启</td>
<td>统一配置</td>
</tr>
<tr>
<td>缺点</td>
<td>不便于管理</td>
<td>需要重启</td>
</tr>
</tbody>
</table>
<h2 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h2><h3 id="全量复制开销"><a href="#全量复制开销" class="headerlink" title="全量复制开销"></a>全量复制开销</h3><ol>
<li>bgsave时间</li>
<li>RDB文件网络传输时间</li>
<li>从节点清空数据时间</li>
<li>从节点加载RDB的时间</li>
</ol>
<h1 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/2019/04/07/Redis%E8%A7%A3%E8%AF%BB/1567577211.jpg" alt="架构图"></p>
<h2 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h2><ol>
<li>多个sentinel发现并确认master有问题</li>
<li>选举出一个sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其余slave成为新的master的slave</li>
<li>通知客户端主从变化</li>
<li>等待老的master复活成为新的master的slave</li>
</ol>
<h2 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h2><ol>
<li>每10秒每个sentinel对master和slave执行info</li>
</ol>
<ul>
<li>发现slave节点</li>
<li>确认主从关系</li>
</ul>
<ol start="2">
<li>每2秒每个sentinel通过master节点的channel交换信息（pub/sub）</li>
</ol>
<ul>
<li>通过<em>sentinel</em>:hello频道交互</li>
<li>交互节点的“看法”和自身信息</li>
</ul>
<ol start="3">
<li>每一秒每个sentinel对其他sentinel和redis执行ping</li>
</ol>
<ul>
<li>心跳检测，失败判定依据</li>
</ul>
<h1 id="缓存的使用与优化"><a href="#缓存的使用与优化" class="headerlink" title="缓存的使用与优化"></a>缓存的使用与优化</h1><h2 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h2><h3 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h3><ol>
<li>加速读写</li>
<li>降低后端负载</li>
</ol>
<h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><ol>
<li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关。</li>
<li>代码维护成本：多了一层缓存逻辑</li>
</ol>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><ol>
<li>LRU/LFU?FIFO算法剔除：例如maxmemory-policy</li>
<li>超时剔除：例如expire</li>
<li>主动更新：开发控制生命周期</li>
</ol>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ol>
<li>低一致性：最大内存和淘汰策略</li>
<li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</li>
</ol>
<h2 id="缓存粒度控制"><a href="#缓存粒度控制" class="headerlink" title="缓存粒度控制"></a>缓存粒度控制</h2><ol>
<li>通用性：全量属性更好</li>
<li>占用空间：部分属性更好</li>
<li>代码维护：表面上全量属性更好</li>
</ol>
<h2 id="缓存穿透问题–大量请求不命中"><a href="#缓存穿透问题–大量请求不命中" class="headerlink" title="缓存穿透问题–大量请求不命中"></a>缓存穿透问题–大量请求不命中</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li>业务代码自身问题</li>
<li>恶意攻击、爬虫等等</li>
</ol>
<h3 id="解决方法1一缓存空对象"><a href="#解决方法1一缓存空对象" class="headerlink" title="解决方法1一缓存空对象"></a>解决方法1一缓存空对象</h3><p>先从缓存中获取值，如果为空，则进去持久层获取值在放进缓存，如果持久层获取的数据也为空，则设置缓存超时时间</p>
<h3 id="解决方法2一布隆过滤器拦截"><a href="#解决方法2一布隆过滤器拦截" class="headerlink" title="解决方法2一布隆过滤器拦截"></a>解决方法2一布隆过滤器拦截</h3><h2 id="无底洞问题"><a href="#无底洞问题" class="headerlink" title="无底洞问题"></a>无底洞问题</h2><h2 id="热点key的重建优化"><a href="#热点key的重建优化" class="headerlink" title="热点key的重建优化"></a>热点key的重建优化</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>减少重缓存的次数</li>
<li>数据尽可能一致</li>
<li>减少潜在危险</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li>互斥锁（mutex key）</li>
<li>永不过去</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP流量控制和拥塞控制</title>
    <url>/2021/04/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p> 流量控制和拥塞控制是TCP实现可靠传输的方法之一</p>
</blockquote>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="为什么要流量控制"><a href="#为什么要流量控制" class="headerlink" title="为什么要流量控制"></a>为什么要流量控制</h2><p>如果发送端的发送速度太快，会导致接收端的接收缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包。 所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。</p>
<h2 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>利用滑动窗口机制可以实现流量控制。</p>
<p>原理就是<strong>运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</strong></p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，<strong>就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：</strong>TCP规定，即使设置为零窗口，接收方也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="什么是拥塞控制"><a href="#什么是拥塞控制" class="headerlink" title="什么是拥塞控制"></a>什么是拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，<strong>如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵</strong>，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
<h2 id="TCP如何实现拥塞控制"><a href="#TCP如何实现拥塞控制" class="headerlink" title="TCP如何实现拥塞控制"></a>TCP如何实现拥塞控制</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p>发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。</p>
<p><strong>接收端窗口（Reciver Window)又称通知窗口（Advertised Window)</strong>,是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。</p>
<p><strong>拥塞窗口cwnd（Congestion Window)</strong>是<strong>发送端</strong>根据自己估计的网络拥塞程度而设置的窗口动态值，是来自发送端的流量控制。</p>
<p>因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即<strong>慢启动（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）</strong></p>
<h3 id="慢启动算法和拥塞避免算法"><a href="#慢启动算法和拥塞避免算法" class="headerlink" title="慢启动算法和拥塞避免算法"></a>慢启动算法和拥塞避免算法</h3><p><img src="/2021/04/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/微信截图_20210407134157.png" alt></p>
<p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p>
<p>当cwnd&lt;ssthresh时，使用慢开始算法。</p>
<p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p>
<p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p>
<h3 id="快重传算法和快恢复算法"><a href="#快重传算法和快恢复算法" class="headerlink" title="快重传算法和快恢复算法"></a>快重传算法和快恢复算法</h3><p> 一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。</p>
<p>   <strong>快重传算法</strong>并非取消了<strong>重传机制</strong>，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。</p>
<p>   <strong>快恢复算法</strong>有以下两个要点：</p>
<ol>
<li><p>当发送方连续收到接收方发来的三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把<strong>cwnd(拥塞窗口)</strong>值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法<strong>，使拥塞窗口的线性增大</strong>。</p>
</li>
</ol>
<p><img src="/2021/04/07/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/微信截图_20210407134649.png" alt></p>
<h1 id="TCP拥塞控制和流量控制的差别"><a href="#TCP拥塞控制和流量控制的差别" class="headerlink" title="TCP拥塞控制和流量控制的差别"></a>TCP拥塞控制和流量控制的差别</h1><ul>
<li><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。</p>
</li>
<li><p>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <url>/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><p><img src="/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/1.jpeg" alt></p>
<p><img src="/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/2.png" alt></p>
<p>客户端与服务器之间数据的发送和返回的过程当中需要创建一个叫TCP connection的东西；</p>
<p>由于TCP不存在连接的概念，只存在请求和响应，请求和响应都是数据包，它们之间都是经过由TCP创建的一个从客户端发起，服务器接收的类似连接的通道，这个连接可以一直保持，http请求是在这个连接的基础上发送的；</p>
<p>在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样：</p>
<ul>
<li><p>在HTTP/1.0中这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，服务器端响应了之后，这个TCP连接就关闭了；</p>
</li>
<li><p>在HTTP/1.1中可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。</p>
</li>
<li><p>如果TCP连接保持，第二个请求发送就没有这“三次握手”的消耗。HTTP/2中同一个TCP连接里还可以并发地传输http请求。</p>
</li>
</ul>
<h1 id="TCP报文格式简介"><a href="#TCP报文格式简介" class="headerlink" title="TCP报文格式简介"></a>TCP报文格式简介</h1><p><img src="/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/3.jpeg" alt></p>
<p>其中比较重要的字段有：</p>
<ol>
<li><p>序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
</li>
<li><p>确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
</li>
<li><p>标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">URG：紧急指针（urgent pointer）有效。</span><br><span class="line">ACK：确认序号有效。PSH：接收方应该尽快将这个报文交给应用层。</span><br><span class="line">RST：重置连接。SYN：发起一个新连接。</span><br><span class="line">FIN：释放一个连接。</span><br><span class="line"></span><br><span class="line">需要注意的是：</span><br><span class="line">不要将确认序号Ack与标志位中的ACK搞混了。确认方<span class="attribute">Ack</span>=发起方Seq+1，两端配对。</span><br></pre></td></tr></table></figure>
<h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p>所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p>
<p><img src="/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/4.jpeg" alt></p>
<p>握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：</p>
<ol>
<li>首先客户端向服务器端发送一段TCP报文，其中：</li>
</ol>
<p>标记位为SYN，表示“请求建立新连接”;</p>
<p>序号为Seq=X（X一般为1）；</p>
<p>随后客户端进入SYN-SENT阶段。</p>
<ol start="2">
<li>服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</li>
</ol>
<p>标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</p>
<p>序号为Seq=y；</p>
<p>确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；</p>
<p>随后服务器端进入SYN-RCVD阶段。</p>
<ol start="3">
<li>客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</li>
</ol>
<p>标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；</p>
<p>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</p>
<p>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</p>
<p>随后客户端进入ESTABLISHED阶段。服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。</p>
<p>在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续”握手”，以此确保了”三次握手”的顺利完成。</p>
<p>此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。</p>
<h1 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h1><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h1 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h1><p>所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。以下为客户端主动发起释放连接的图解：</p>
<p><img src="/2021/04/24/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/5.jpeg" alt></p>
<ol>
<li>首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：</li>
</ol>
<p>标记位为FIN，表示“请求释放连接“；序号为Seq=U；随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。</p>
<p>注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。</p>
<ol start="2">
<li>服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：</li>
</ol>
<p>标记位为ACK，表示“接收到客户端发送的释放连接的请求”；序号为Seq=V；确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</p>
<p>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了</p>
<ol start="3">
<li>服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：</li>
</ol>
<p>标记位为FIN，ACK，表示“已经准备好释放连接了”。</p>
<p>注意：这里的ACK并不是确认收到服务器端报文的确认报文。</p>
<p>序号为Seq=W；确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。</p>
<ol start="4">
<li>客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：</li>
</ol>
<p>标记位为ACK，表示“接收到服务器准备好释放连接的信号”。序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。随后客户端开始在TIME-WAIT阶段等待<code>2MSL</code></p>
<h1 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h1><p>为的是确认服务器端是否收到客户端发出的ACK确认报文</p>
<p>当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。</p>
<p>服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；</p>
<ul>
<li><p>如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；</p>
</li>
<li><p>否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。</p>
</li>
</ul>
<p>所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因</p>
<h1 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h1><p>断开一个 TCP 连接则需要“四次挥手”：</p>
<p>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</p>
<p>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</p>
<p>服务器-关闭与客户端的连接，发送一个FIN给客户端</p>
<p>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>参考：<a href="https://baijiahao.baidu.com/s?id=1654225744653405133&amp;wfr=spider&amp;for=pc"></a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的容器</title>
    <url>/2019/04/18/Spring%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Spring提供了两种容器类型： BeanFactory和ApplicationContext。<br> BeanFactory。基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延<br>迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对<br>该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需<br>要的资源有限。对于资源有限，并且功能要求不是很严格的场景， BeanFactory是比较合适的<br>IoC容器选择。<br>ApplicationContext。 ApplicationContext在BeanFactory的基础上构建，是相对比较高<br>级的容器实现，除了拥有BeanFactory的所有支持， ApplicationContext还提供了其他高级  特性，比如事件发布、国际化信息支持等，这些会在后面详述。 ApplicationContext所管理<br>的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来<br>说， ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容<br>器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，<br>ApplicationContext类型的容器是比较合适的选择。  </p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP粘包拆包及解决方法</title>
    <url>/2020/02/11/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>
</blockquote>
<h1 id="什么是粘包、拆包？"><a href="#什么是粘包、拆包？" class="headerlink" title="什么是粘包、拆包？"></a>什么是粘包、拆包？</h1><p>假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p>
<p><strong>第一种情况：</strong>接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p>
<p><img src="/2020/02/11/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg" alt></p>
<p><strong>第二种情况：</strong>接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p><img src="/2020/02/11/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/2.jpg" alt></p>
<p><strong>第三种情况：</strong>这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p><img src="/2020/02/11/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/3.jpg" alt></p>
<p><img src="/2020/02/11/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/4.jpg" alt></p>
<h1 id="为什么会发生TCP粘包、拆包？"><a href="#为什么会发生TCP粘包、拆包？" class="headerlink" title="为什么会发生TCP粘包、拆包？"></a>为什么会发生TCP粘包、拆包？</h1><p>发生TCP粘包、拆包主要是由于下面一些原因：</p>
<ul>
<li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li>
<li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li>
<li>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ul>
<h1 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h1><p>TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：</p>
<ol>
<li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li>
<li>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li>
<li>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix系统下的五种IO模型</title>
    <url>/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>Unix系统下，I/O模型一共有五种：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O和异步I/O</p>
</blockquote>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O?"></a>I/O?</h1><p>I/O（Input/Output）即输入/输出。</p>
<p><strong>从计算机结构的角度来解读一下 I/O。</strong></p>
<p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信图片_20210310114716.jpg" alt="微信图片_20210310114716"></p>
<p>输入设备（比如键盘）和输出设备（比如鼠标）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p>
<p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p>
<p>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</p>
<p><strong>再先从应用程序的角度来解读一下 I/O。</strong></p>
<p>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong>和 <strong>内核空间（Kernel space ）</strong> 。</p>
<p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p>
<p>并且，用户空间的程序不能直接访问内核空间。</p>
<p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p>
<p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p>
<p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和相应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>
<ol>
<li><p>内核等待 I/O 设备准备好数据</p>
</li>
<li><p>内核将数据从内核空间拷贝到用户空间。</p>
</li>
</ol>
<p>IO模型的区别主要都在这两个阶段上面所以很重要，我们所说的同步与异步的区别，在于第二个阶段中，将数据从内核拷贝到线程（或进程）中，如果被阻塞了就同步，没有被阻塞就是异步。被阻塞了说明该阶段的操作是依赖用户线程的，而没有被阻塞说明不依赖用户线程，而依赖内核，所以异步是需要操作系统内核支持的。</p>
<p>阻塞IO与非阻塞IO则是发生在IO操作第一个阶段的。</p>
<p>阻塞IO是指当一个线程发起IO操作请求时，系统内核会去查看要操作的数据是否就绪，当是阻塞IO时，发现要操作是数据没有就绪，就会一直等待下去，直到数据准备就绪；当是非阻塞IO时如果数据没有准备好，就会返回一个标识信息告诉调用线程，当前操作数据没有准备就绪。当数据准备就绪后才会执行第一阶段。</p>
<p>其实阻塞IO与非阻塞IO的关键区别在于，是等待执行，还是说立即返回一个通知标识。当数据没有准备好时就等待执行，而当立即返回一个通知标识时，线程会根据标识知道现在数据是个什么情况，如果没有准备好，那么线程会再次发起请求，知道数据准备好后立即执行。</p>
<h1 id="同步和异步？"><a href="#同步和异步？" class="headerlink" title="同步和异步？"></a>同步和异步？</h1><p>同步就是多个任务或事件在执行时需要按顺序逐个执行，如果排在顺序前面的任务或事件在执行的时候，排在后面的任务或事件就需要等待前面的执行完后才可以执行，这些任务或事件是不能并行执行的。同步执行任务可以被设计为可靠的任务序列，前后两个任务可以保持一致才算整个任务结束。</p>
<p>异步是多个任务或事件可以同时并行执行，前面的任务不会导致后面的任务的等待。因为是多个任务同时进行的，所以每个任务之间不产生相互的依赖，所以无法保证可靠性。</p>
<p>同步流程图</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/772743-20190902235132996-660324540.png" alt="772743-20190902235132996-660324540"></p>
<p>异步流程图</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/772743-20190903000032601-1472302618.png" alt="772743-20190903000032601-1472302618"></p>
<h1 id="阻塞和非阻塞？"><a href="#阻塞和非阻塞？" class="headerlink" title="阻塞和非阻塞？"></a>阻塞和非阻塞？</h1><p>阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，那么就会一直等待，直到条件满足后，才继续执行后面的其他工作。</p>
<p>非阻塞是指当有任务在执行时，会发出一个请求操作，如果该请求操作需要的条件不满足的话，会立即返回一个标志信息告知条件不满足，而不会一直在等待下去。</p>
<p>阻塞流程</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/772743-20190903010837823-947403378.png" alt="772743-20190903010837823-947403378"></p>
<p>非阻塞流程</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/772743-20190903011515281-2072868827.png" alt="772743-20190903011515281-2072868827"></p>
<p>同步与异步这组概念的重点在于，前面的任务是否会导致整个流程的等待。</p>
<p>阻塞与非阻塞这组概念的重点在于，如果操作请求不满足条件是否会返回一个标志信息告知不满足条件。</p>
<p>其实理解阻塞与非阻塞可以从我们通常所接触的线程阻塞来理解，当出现慢任务的时候，线程会发生阻塞，cpu会等待慢任务执行完成后再执行后续的任务。而非阻塞线程在执行这个慢任务的时候，会去做其他事情，当慢任务执行完成后，再去执行后面的任务。非阻塞虽然看似可以明显提高效率，但是系统的线程切换也是会造成时间损耗，所以需要合理利用。</p>
<h1 id="组合分析"><a href="#组合分析" class="headerlink" title="组合分析"></a>组合分析</h1><table>
<thead>
<tr>
<th>组合方式</th>
<th>性能分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td>最常用的一种用法，使用也是最简单的，但是I/O性能一般很差，CPU大部分处于空闲状态。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提升I/O性能的常用手段，就是将I/O的阻塞改为非阻塞方式，尤其在网络I/O是长连接同时传输数据也不很多的情况下，提升性能非常有效。这种方式通常能提升I/O性能，但是会增加CPU消耗，要考虑增加的I/O性能能不能补偿CPU的消耗，也就是系统的瓶颈是在I/O上还是在CPU上。</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>这种方式在分布式数据库中经常用到，例如，在一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2~3份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写I/O。异步阻塞对网络I/O能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下用，集群之间的消息同步机制一般用这种I/O组合方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大却非常频繁的情况。这种网络I/O用此方式性能达到最高。</td>
</tr>
</tbody>
</table>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO(Blocking I/O)"></a>BIO(Blocking I/O)</h2><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信截图_20210310142515.png" alt="微信截图_20210310142515"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<h2 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO(Non-blocking/New I/O)"></a>NIO(Non-blocking/New I/O)</h2><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p><strong>同步非阻塞 IO 模型</strong></p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/20210310142328.png" alt="20210310142328"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<h2 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I/O 多路复用模型"></a>I/O 多路复用模型</h2><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信图片_20210310142237.png" alt="微信图片_20210310142237"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信截图_20210310142158.png" alt="微信截图_20210310142158"></p>
<h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><p>在信号驱动IO模型中，让内核在数据报准备就绪时发送SIGIO信号通知用户线程。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/772743-20190922172245805-84723612.png" alt="772743-20190922172245805-84723612"></p>
<p>首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，也就是说没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后就可以在信号处理函数中调用recvfrom读取数据报，并通知用户进程数据已经准备好了，可以读取了。</p>
<p>这种模型的优点在于等待数据报到达期间不会被阻塞，用户进程可以继续执行，只要等待来自信号处理函数的通知即可。</p>
<h2 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h2><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信图片_20210310141857.png" alt="微信图片_20210310141857"></p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2021/03/10/Unix%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/微信图片_20210310141745.png" alt="微信图片_20210310141745"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>个人对于Vuex的理解</title>
    <url>/2019/03/23/%E4%B8%AA%E4%BA%BA%E5%AF%B9%E4%BA%8EVuex%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<p>官方文档：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>state:Vuex中的数据源，我们需要保存的数据就保存在这里。相当于vue中的data,用$store.state.modules名.xxx来获取</p>
<p>mutations:相当于vue中的methods,用this.$store.commit(‘事件名’)来获取</p>
<p>actions:vuex中的actions是支持异步的,可理解为当组件需要调用多次mutations中的事件时,可将事件写入actions中,用$store.dispatch(‘事件名’)来获取</p>
<p>getters:相当于vue中的computed计算属性。用于过滤,组合state。比如说state里面存了一个数组，数组有好多个数据，而我只想要用status：0的那些个，就可以用getters</p>
<p>modules:将store分割成模块，避免混淆</p>
<p>Vuex:可看作是个在vue中创建全局变量的东西,Vuex提供了一些优雅的方法，可以让我们改变全局变量的值</p>
<p>注:刷新页面Vuex会进行丢失数据，可配合session防止页面刷新丢失数据</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>路遥--平凡的世界 观后感</title>
    <url>/2019/10/15/%5B%E8%B7%AF%E9%81%A5--%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C%5D%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>路遥（1949年12月3日—1992年11月17日），本名王卫国，出生于陕北榆林清涧县，中国当代作家，代表作有长篇小说《平凡的世界》、《人生》等。 [1]  曾任中国作家协会陕西分会党组成员、副主席。<br>路遥1949年12月3日出生于陕西陕北山区清涧县一个贫困的农民家庭，7岁时因为家里困难被过继给延川县农村的伯父。曾在延川县立中学学习，1969年回乡务农。这段时间里他做过许多临时性的工作，并在农村一小学中教过一年书。1973年进入延安大学中文系学习，其间开始文学创作。大学毕业后，任《陕西文艺》（今为《延河》）编辑。1980年发表《惊人动魄的一幕》，获得第一届全国优秀中篇小说奖。1982年发表中篇小说《人生》，后被改编为电影。1991年完成百万字的长篇巨著《平凡的世界》，这部小说以其恢宏的气势和史诗般的品格，全景式地表现了改革时代中国城乡的社会生活和人们思想情感的巨大变迁，还未完成即在中央人民电台广播。路遥因此而荣获茅盾文学奖。<br>1992年11月17日，路遥因肝硬化腹水医治无效在西安逝世，年仅42岁。 [1]  2018年12月18日，党中央、国务院授予路遥同志改革先锋称号，颁授改革先锋奖章，并获评鼓舞亿万农村青年投身改革开放的优秀作家。</p>
<p>参考：百度百科：<a href="https://baike.baidu.com/item/路遥/216?fr=aladdin">https://baike.baidu.com/item/路遥/216?fr=aladdin</a></p>
<h2 id="作品简介"><a href="#作品简介" class="headerlink" title="作品简介"></a>作品简介</h2><p>《平凡的世界》是中国作家路遥创作的一部百万字的小说。这是一部全景式地表现中国当代城乡社会生活的长篇小说，全书共三部。1986年12月首次出版。<br>该书以中国70年代中期到80年代中期十年间为背景，通过复杂的矛盾纠葛，以孙少安和孙少平两兄弟为中心，刻画了当时社会各阶层众多普通人的形象；劳动与爱情、挫折与追求、痛苦与欢乐、日常生活与巨大社会冲突纷繁地交织在一起，深刻地展示了普通人在大时代历史进程中所走过的艰难曲折的道路。1991年3月，《平凡的世界》获中国第三届茅盾文学奖。</p>
<p>参考：百度百科：<a href="https://baike.baidu.com/item/平凡的世界/166?fr=aladdin">https://baike.baidu.com/item/平凡的世界/166?fr=aladdin</a></p>
<h2 id="个人观后感"><a href="#个人观后感" class="headerlink" title="个人观后感"></a>个人观后感</h2><p>阅读完本书给我的最大感受是每个人可以在书中找到自己的一个角色，作者在书中刻画了不同阶层，不同身份的人物，刻画了不同道路上的曲折。而书中的主人公孙少平正是现今的我应该去学习的，他不甘平庸，有理想，试图通过自己的努力去改变自己的人生。平凡的村子，平凡的土地，平凡的农民，平凡的爱情，平凡的亲情，平凡的一切。人生的道路，当你得到一些东西时，可能一会伴随的失去一些东西，孙少平的人生亦是如此，我们的人生也是如此。而现今的我，应该去做好一道最重要的选择题……</p>
<blockquote>
<p>生活不止眼前的苟且，还有诗和远方。</p>
</blockquote>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker搭建MongoDB副本集</title>
    <url>/2021/05/02/%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAMongoDB%E5%89%AF%E6%9C%AC%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p> 实现MongoDB高可用服务</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>mongodb集群搭建有三种方式。</p>
<ol>
<li><p>Master-Slave模式</p>
</li>
<li><p>Replica-Set方式</p>
</li>
<li><p>Sharding方式</p>
</li>
</ol>
<p>其中，第一种方式基本没什么意义，官方也不推荐这种方式搭建。因为主从复制虽然可以承受一定的负载压力，但这种方式仍然是一个单点，如果主库挂了，数据写入就成了风险。另外两种分别就是副本集和分片的方式。分片用于存储海量的数据时使用。</p>
<h2 id="Replica-Sets复制集"><a href="#Replica-Sets复制集" class="headerlink" title="Replica Sets复制集"></a>Replica Sets复制集</h2><p>MongoDB在1.6版本对开发了新功能replica set，这比之前的主从复制功能要强大一 些，增加了故障自动切换和自动修复成员节点，各个DB之间数据完全一致，大大降低了维护成本。</p>
<p>MongoDB复制是将数据同步在多个服务器的过程。</p>
<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>
<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="生成keyFile"><a href="#生成keyFile" class="headerlink" title="生成keyFile"></a>生成keyFile</h2><ul>
<li>MongoDB使用keyfile认证，副本集中的每个mongod实例使用keyfile内容作为认证其他成员的共享密码。mongod实例只有拥有正确的keyfile才可以加入副本集。</li>
<li>keyFile的内容必须是6到1024个字符的长度，且副本集所有成员的keyFile内容必须相同。</li>
<li>有一点要注意是的：在UNIX系统中，keyFile必须没有组权限或完全权限（也就是权限要设置成X00的形式）。Windows系统中，keyFile权限没有被检查。</li>
<li>可以使用任意方法生成keyFile。例如，如下操作使用openssl生成复杂的随机的1024个字符串。然后使用chmod修改文件权限，只给文件拥有者提供读权限。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 400权限是要保证安全性，否则mongod启动会报错</span></span><br><span class="line"><span class="attribute">openssl</span> rand -base<span class="number">64</span> <span class="number">756</span> &gt; mongodb.key</span><br><span class="line"><span class="attribute">chmod</span> <span class="number">400</span> mongodb.key</span><br></pre></td></tr></table></figure>
<p>将生成的keyFile复制到其他节点服务器上，保证每一个副本集成员使用相同的keyFile文件</p>
<h2 id="通过docker-compose启动MongoDB"><a href="#通过docker-compose启动MongoDB" class="headerlink" title="通过docker-compose启动MongoDB"></a>通过docker-compose启动MongoDB</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mongo:</span><br><span class="line">    image: mongo:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/mongo:/data/db</span><br><span class="line">      - ./data/mongo/log:/data/log</span><br><span class="line">      - ./mongodb.key:/data/mongodb.key</span><br><span class="line">    user: root</span><br><span class="line">    environment:</span><br><span class="line">      - MONGO_INITDB_ROOT_USERNAME=username</span><br><span class="line">      - MONGO_INITDB_ROOT_PASSWORD=password</span><br><span class="line">      - MONGO_INITDB_DATABASE=init</span><br><span class="line">    container_name: mongodb</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">27017</span>:<span class="number">27017</span></span><br><span class="line">    command: mongod --replSet mongos --keyFile /data/mongodb.key</span><br><span class="line">    restart: always</span><br><span class="line">    entrypoint:</span><br><span class="line">      - bash</span><br><span class="line">      - -c</span><br><span class="line">      - |</span><br><span class="line">        chmod <span class="number">400</span> /data/mongodb.key</span><br><span class="line">        chown <span class="number">999</span>:<span class="number">999</span> /data/mongodb.key</span><br><span class="line">        exec docker-entrypoint.sh $$@</span><br></pre></td></tr></table></figure>
<p>文件详解</p>
<ul>
<li><code>chown 999:999 /data/mongodb.key</code> 999用户是容器中的mongod用户，通过chown修改文件用户权限</li>
<li><code>mongod --replSet mongos --keyFile /data/mongodb.key</code> 启动命令</li>
<li><code>--replSet mongos</code> 以副本集形式启动并将副本集名字命名为 mongos </li>
<li><code>--keyFile /data/mongodb.key</code> 设置keyFile，用于副本集通信，文件通过 volumes 映射到容器内</li>
</ul>
<p>在各个节点服务器启动mongo</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> <span class="operator">-f</span>  docker<span class="literal">-compose</span><span class="literal">-mongo</span>.yml up <span class="literal">-d</span></span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>进入其中一个mongo容器内</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it mongodb <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>登录</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mongo -u 账号 -<span class="selector-tag">p</span> 密码</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>登录成功可以查看状态</li>
</ol>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&gt; rs.status()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : 0,</span><br><span class="line">	<span class="string">&quot;errmsg&quot;</span> : &quot;<span class="type">no</span> replset config has been received<span class="string">&quot;,</span></span><br><span class="line"><span class="string">	&quot;</span>code<span class="string">&quot; : 94,</span></span><br><span class="line"><span class="string">	&quot;</span>codeName<span class="string">&quot; : &quot;</span>NotYetInitialized<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置副本集</li>
</ol>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">config = &#123; <span class="variable">_id</span>:<span class="string">&quot;mongos&quot;</span>, <span class="built_in">members</span>:[&#123;<span class="variable">_id</span>:<span class="number">0</span>,host:<span class="string">&quot;ip:27017&quot;</span>&#125;,&#123;<span class="variable">_id</span>:<span class="number">1</span>,host:<span class="string">&quot;ip:27017&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="variable">_id</span>:<span class="number">2</span>,host:<span class="string">&quot;ip:27017&quot;</span>&#125;]&#125;</span><br><span class="line">rs.initiate(config);</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面提示ok就是表示成功了，这时候会选举出Primary节点。重新通过<code>rs.status()</code>查看状态就能看到了。</p>
<p>通过<code>rs.status()</code>的输出我们就能分出那个是<code>PRIMARY</code>节点了。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li>在主节点插入数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongos:PRIMARY&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">mongos:PRIMARY&gt; db</span><br><span class="line">test</span><br><span class="line">mongos:PRIMARY&gt; db.test.insert(&#123;&quot;name&quot;:&quot;测试&quot;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看从节点数据</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mongos:SECONDARY&gt; use test</span><br><span class="line">switched to db test</span><br><span class="line">mongos:SECONDARY&gt; db</span><br><span class="line">test</span><br><span class="line">mongos:SECONDARY&gt; db.test.<span class="built_in">find</span>()</span><br><span class="line">Error: error: &#123;</span><br><span class="line">	<span class="string">&quot;topologyVersion&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;processId&quot;</span> : <span class="built_in">ObjectId</span>(<span class="string">&quot;6093a0eb00c54d058f6c6419&quot;</span>),</span><br><span class="line">		<span class="string">&quot;counter&quot;</span> : <span class="built_in">NumberLong</span>(<span class="number">4</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : <span class="built_in">Timestamp</span>(<span class="number">1620290083</span>, <span class="number">1</span>),</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : <span class="number">0</span>,</span><br><span class="line">	<span class="string">&quot;errmsg&quot;</span> : <span class="string">&quot;not master and slaveOk=false&quot;</span>,</span><br><span class="line">	<span class="string">&quot;code&quot;</span> : <span class="number">13435</span>,</span><br><span class="line">	<span class="string">&quot;codeName&quot;</span> : <span class="string">&quot;NotPrimaryNoSecondaryOk&quot;</span>,</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : <span class="built_in">Timestamp</span>(<span class="number">1620290083</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : <span class="built_in">BinData</span>(<span class="number">0</span>,<span class="string">&quot;1yNWjsrfQeHQyfQFkXeo0qxhJco=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : <span class="built_in">NumberLong</span>(<span class="string">&quot;6959084154784841732&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">mongos:SECONDARY&gt; rs.<span class="built_in">slaveOk</span>()</span><br><span class="line">WARNING: <span class="built_in">slaveOk</span>() is deprecated and may be removed in the next major release. Please use <span class="built_in">secondaryOk</span>() instead.</span><br><span class="line">mongos:SECONDARY&gt; rs.<span class="built_in">secondaryOk</span>()</span><br><span class="line">mongos:SECONDARY&gt; db.test.<span class="built_in">find</span>()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="built_in">ObjectId</span>(<span class="string">&quot;6093a741215b2bd65f67b68b&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;测试&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>测试通过，在从节点可以看到在主节点添加的数据。</p>
<p>注意：执行db.test.find()报”not master and slaveOk=false”，这是正常情况，因为初始化的时候slave默认不允许读写</p>
<h1 id="添加成员"><a href="#添加成员" class="headerlink" title="添加成员"></a>添加成员</h1><p>在主节点执行rs.add(“ip:27017”)</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">mongos:PRIMARY&gt; rs.add(<span class="string">&quot;ip:27019&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;ok&quot;</span> : 1,</span><br><span class="line">	<span class="string">&quot;$clusterTime&quot;</span> : &#123;</span><br><span class="line">		<span class="string">&quot;clusterTime&quot;</span> : <span class="type">Timestamp</span>(<span class="number">1620291932</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="string">&quot;signature&quot;</span> : &#123;</span><br><span class="line">			<span class="string">&quot;hash&quot;</span> : <span class="type">BinData</span>(<span class="number">0</span>,<span class="string">&quot;7rHK33BLGBnUI/Wcm1RUpkGglEY=&quot;</span>),</span><br><span class="line">			<span class="string">&quot;keyId&quot;</span> : <span class="type">NumberLong</span>(<span class="string">&quot;6959084154784841732&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;operationTime&quot;</span> : <span class="type">Timestamp</span>(<span class="number">1620291932</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次通过rs.status()查看</p>
<h1 id="更换主节点"><a href="#更换主节点" class="headerlink" title="更换主节点"></a>更换主节点</h1><p>在主节点修改配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//查看当前配置，存入config变量中</span><br><span class="line">mongos:PRIMARY&gt; config=rs.conf()</span><br><span class="line">//修改config变量，将第二个成员的优先级设为2</span><br><span class="line">mongos:PRIMARY&gt; config.members[1].priority = 2</span><br><span class="line">2</span><br><span class="line">//配置生效</span><br><span class="line">mongos:PRIMARY&gt; rs.reconfig(config)</span><br><span class="line">// 查看状态</span><br><span class="line">mongos:PRIMARY&gt; rs.status()</span><br><span class="line">&#123;</span><br><span class="line">	&quot;set&quot; : &quot;mongos&quot;,</span><br><span class="line">	&quot;date&quot; : ISODate(&quot;2021-05-06T09:20:57.517Z&quot;),</span><br><span class="line">	&quot;myState&quot; : 2,</span><br><span class="line">	&quot;term&quot; : NumberLong(2),</span><br><span class="line">	&quot;syncSourceHost&quot; : &quot;192.168.6.128:27019&quot;,</span><br><span class="line">	&quot;syncSourceId&quot; : 2,</span><br><span class="line">	&quot;heartbeatIntervalMillis&quot; : NumberLong(2000),</span><br><span class="line">	&quot;majorityVoteCount&quot; : 2,</span><br><span class="line">	&quot;writeMajorityCount&quot; : 2,</span><br><span class="line">	&quot;votingMembersCount&quot; : 3,</span><br><span class="line">	&quot;writableVotingMembersCount&quot; : 3,</span><br><span class="line">	&quot;optimes&quot; : &#123;</span><br><span class="line">		&quot;lastCommittedOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(2)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;lastCommittedWallTime&quot; : ISODate(&quot;2021-05-06T09:20:40.488Z&quot;),</span><br><span class="line">		&quot;readConcernMajorityOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(2)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;readConcernMajorityWallTime&quot; : ISODate(&quot;2021-05-06T09:20:40.488Z&quot;),</span><br><span class="line">		&quot;appliedOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(2)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;durableOpTime&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(2)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;lastAppliedWallTime&quot; : ISODate(&quot;2021-05-06T09:20:40.488Z&quot;),</span><br><span class="line">		&quot;lastDurableWallTime&quot; : ISODate(&quot;2021-05-06T09:20:40.488Z&quot;)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;lastStableRecoveryTimestamp&quot; : Timestamp(1620292840, 1),</span><br><span class="line">	&quot;electionParticipantMetrics&quot; : &#123;</span><br><span class="line">		&quot;votedForCandidate&quot; : true,</span><br><span class="line">		&quot;electionTerm&quot; : NumberLong(2),</span><br><span class="line">		&quot;lastVoteDate&quot; : ISODate(&quot;2021-05-06T09:20:28.156Z&quot;),</span><br><span class="line">		&quot;electionCandidateMemberId&quot; : 1,</span><br><span class="line">		&quot;voteReason&quot; : &quot;&quot;,</span><br><span class="line">		&quot;lastAppliedOpTimeAtElection&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292817, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;maxAppliedOpTimeInSet&quot; : &#123;</span><br><span class="line">			&quot;ts&quot; : Timestamp(1620292817, 1),</span><br><span class="line">			&quot;t&quot; : NumberLong(1)</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;priorityAtElection&quot; : 1,</span><br><span class="line">		&quot;newTermStartDate&quot; : ISODate(&quot;2021-05-06T09:20:28.213Z&quot;),</span><br><span class="line">		&quot;newTermAppliedDate&quot; : ISODate(&quot;2021-05-06T09:20:29.266Z&quot;)</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;members&quot; : [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 0,</span><br><span class="line">			&quot;name&quot; : &quot;192.168.6.128:27017&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 2,</span><br><span class="line">			&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">			&quot;uptime&quot; : 5418,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(2)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-05-06T09:20:40Z&quot;),</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;192.168.6.128:27019&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : 2,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;configVersion&quot; : 3,</span><br><span class="line">			&quot;configTerm&quot; : 2,</span><br><span class="line">			&quot;self&quot; : true,</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 1,</span><br><span class="line">			&quot;name&quot; : &quot;192.168.6.128:27018&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 1,</span><br><span class="line">			&quot;stateStr&quot; : &quot;PRIMARY&quot;, //已被设置为主节点</span><br><span class="line">			&quot;uptime&quot; : 4824,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(2)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDurable&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(2)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-05-06T09:20:40Z&quot;),</span><br><span class="line">			&quot;optimeDurableDate&quot; : ISODate(&quot;2021-05-06T09:20:40Z&quot;),</span><br><span class="line">			&quot;lastHeartbeat&quot; : ISODate(&quot;2021-05-06T09:20:55.545Z&quot;),</span><br><span class="line">			&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2021-05-06T09:20:56.257Z&quot;),</span><br><span class="line">			&quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : -1,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;electionTime&quot; : Timestamp(1620292828, 1),</span><br><span class="line">			&quot;electionDate&quot; : ISODate(&quot;2021-05-06T09:20:28Z&quot;),</span><br><span class="line">			&quot;configVersion&quot; : 3,</span><br><span class="line">			&quot;configTerm&quot; : 2</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;_id&quot; : 2,</span><br><span class="line">			&quot;name&quot; : &quot;192.168.6.128:27019&quot;,</span><br><span class="line">			&quot;health&quot; : 1,</span><br><span class="line">			&quot;state&quot; : 2,</span><br><span class="line">			&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">			&quot;uptime&quot; : 924,</span><br><span class="line">			&quot;optime&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(2)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDurable&quot; : &#123;</span><br><span class="line">				&quot;ts&quot; : Timestamp(1620292840, 1),</span><br><span class="line">				&quot;t&quot; : NumberLong(2)</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;optimeDate&quot; : ISODate(&quot;2021-05-06T09:20:40Z&quot;),</span><br><span class="line">			&quot;optimeDurableDate&quot; : ISODate(&quot;2021-05-06T09:20:40Z&quot;),</span><br><span class="line">			&quot;lastHeartbeat&quot; : ISODate(&quot;2021-05-06T09:20:55.543Z&quot;),</span><br><span class="line">			&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2021-05-06T09:20:56.547Z&quot;),</span><br><span class="line">			&quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">			&quot;lastHeartbeatMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;syncSourceHost&quot; : &quot;192.168.6.128:27018&quot;,</span><br><span class="line">			&quot;syncSourceId&quot; : 1,</span><br><span class="line">			&quot;infoMessage&quot; : &quot;&quot;,</span><br><span class="line">			&quot;configVersion&quot; : 3,</span><br><span class="line">			&quot;configTerm&quot; : 2</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	&quot;ok&quot; : 1,</span><br><span class="line">	&quot;$clusterTime&quot; : &#123;</span><br><span class="line">		&quot;clusterTime&quot; : Timestamp(1620292840, 1),</span><br><span class="line">		&quot;signature&quot; : &#123;</span><br><span class="line">			&quot;hash&quot; : BinData(0,&quot;OizMd+vrzvez8MC+7baAHt0Iy8M=&quot;),</span><br><span class="line">			&quot;keyId&quot; : NumberLong(&quot;6959084154784841732&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;operationTime&quot; : Timestamp(1620292840, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ELK做日志收集</title>
    <url>/2020/08/31/%E4%BD%BF%E7%94%A8ELK%E5%81%9A%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p> 微服务系统的日志都保存在各自指定的目录中，如果这些微服务部署在不同的服务器上，那么日志文件也是分散在各自的服务器上。分散的日志不利于我们快速通过日志定位问题，我们可以借助ELK来收集各个微服务系统的日志并集中展示。<br>ELK即Elasticsearch、Logstash和Kibana首字母缩写。Elasticsearch用于存储日志信息，Logstash用于收集日志，Kibana用于图形化展示。 </p>
</blockquote>
<h1 id="搭建ELK环境"><a href="#搭建ELK环境" class="headerlink" title="搭建ELK环境"></a>搭建ELK环境</h1><p> 在Windwos上搭建ELK环境较为麻烦，这里我选择在CentOS7 上通过Docker来搭建ELK环境。</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="安装Docker所需要的包"><a href="#安装Docker所需要的包" class="headerlink" title="安装Docker所需要的包"></a>安装Docker所需要的包</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">yum</span> install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-<span class="class"><span class="keyword">data</span> \</span></span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<h3 id="设置稳定的仓库"><a href="#设置稳定的仓库" class="headerlink" title="设置稳定的仓库"></a>设置稳定的仓库</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="安装最新版的Docker引擎"><a href="#安装最新版的Docker引擎" class="headerlink" title="安装最新版的Docker引擎"></a>安装最新版的Docker引擎</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure>
<h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>
<h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker -v</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h2><p> 安装好Docker后，我们接着安装Docker Compose，官方安装教程<a href="https://docs.docker.com/compose/install/，主要步骤为：">https://docs.docker.com/compose/install/，主要步骤为：</a> </p>
<h3 id="获取Docker-Compose的最新稳定版本"><a href="#获取Docker-Compose的最新稳定版本" class="headerlink" title="获取Docker Compose的最新稳定版本"></a>获取Docker Compose的最新稳定版本</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="对二进制文件授予可执行权限"><a href="#对二进制文件授予可执行权限" class="headerlink" title="对二进制文件授予可执行权限"></a>对二进制文件授予可执行权限</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="创建link"><a href="#创建link" class="headerlink" title="创建link"></a>创建link</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose <span class="regexp">/usr/</span>bin/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="查看是否安装成功-1"><a href="#查看是否安装成功-1" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose -v</span></span><br></pre></td></tr></table></figure>
<h2 id="Docker-Compose搭建ELK"><a href="#Docker-Compose搭建ELK" class="headerlink" title="Docker Compose搭建ELK"></a>Docker Compose搭建ELK</h2><p>在搭建ELK之前，我们需要做一些准备工作。</p>
<p>正如官方所说的那样 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html，Elasticsearch默认使用mmapfs目录来存储索引。操作系统默认的mmap计数太低可能导致内存不足，我们可以使用下面这条命令来增加内存：">https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html，Elasticsearch默认使用mmapfs目录来存储索引。操作系统默认的mmap计数太低可能导致内存不足，我们可以使用下面这条命令来增加内存：</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.<span class="attribute">max_map_count</span>=262144</span><br></pre></td></tr></table></figure>
<h3 id="创建Elasticsearch数据挂载路径"><a href="#创建Elasticsearch数据挂载路径" class="headerlink" title="创建Elasticsearch数据挂载路径"></a>创建Elasticsearch数据挂载路径</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/lxb/</span>elasticsearch/data</span><br></pre></td></tr></table></figure>
<h3 id="对该路径授予777权限"><a href="#对该路径授予777权限" class="headerlink" title="对该路径授予777权限"></a>对该路径授予777权限</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">777</span> <span class="regexp">/lxb/</span>elasticsearch/data</span><br></pre></td></tr></table></figure>
<h3 id="创建Elasticsearch插件挂载路径"><a href="#创建Elasticsearch插件挂载路径" class="headerlink" title="创建Elasticsearch插件挂载路径"></a>创建Elasticsearch插件挂载路径</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/lxb/</span>elasticsearch/plugins</span><br></pre></td></tr></table></figure>
<h3 id="创建Logstash配置文件存储路径"><a href="#创建Logstash配置文件存储路径" class="headerlink" title="创建Logstash配置文件存储路径"></a>创建Logstash配置文件存储路径</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/lxb/</span>logstash</span><br></pre></td></tr></table></figure>
<p>在该路径下创建<code>logstash-lxb.conf</code>配置文件（没有安装vim的话可以使用<code>yum install vim</code>命令安装)</p>
<p>内容如下所示:</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    <span class="attr">mode</span> =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    <span class="attr">port</span> =&gt; <span class="number">4560</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; <span class="string">&quot;es:9200&quot;</span></span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">&quot;lxb-logstash-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建ELK-Docker-Compose文件存储路径"><a href="#创建ELK-Docker-Compose文件存储路径" class="headerlink" title="创建ELK Docker Compose文件存储路径"></a>创建ELK Docker Compose文件存储路径</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="regexp">/lxb/</span>elk</span><br></pre></td></tr></table></figure>
<p> 在该目录下创建<code>docker-compose.yml</code>文件： </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/lxb/</span>elk/docker-compose.yml</span><br></pre></td></tr></table></figure>
<p> 内容如下所示： </p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  elasticsearch:</span></span><br><span class="line"><span class="symbol">    image:</span> elasticsearch:<span class="number">6.4</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">    container_name:</span> elasticsearch</span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line">      - <span class="string">&quot;cluster.name=elasticsearch&quot;</span> <span class="meta">#集群名称为elasticsearch</span></span><br><span class="line">      - <span class="string">&quot;discovery.type=single-node&quot;</span> <span class="meta">#单节点启动</span></span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class="meta">#jvm内存分配为512MB</span></span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - <span class="meta-keyword">/lxb/</span>elasticsearch/plugins:<span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/elasticsearch/</span>plugins</span><br><span class="line">      - <span class="meta-keyword">/lxb/</span>elasticsearch/data:<span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/elasticsearch/</span>data</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="number">9200</span>:<span class="number">9200</span></span><br><span class="line"><span class="symbol">  kibana:</span></span><br><span class="line"><span class="symbol">    image:</span> kibana:<span class="number">6.4</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">    container_name:</span> kibana</span><br><span class="line"><span class="symbol">    links:</span></span><br><span class="line">      - elasticsearch:es <span class="meta">#配置elasticsearch域名为es</span></span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - elasticsearch</span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line">      - <span class="string">&quot;elasticsearch.hosts=http://es:9200&quot;</span> <span class="meta">#因为上面配置了域名，所以这里可以简写为http:<span class="comment">//es:9200</span></span></span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="number">5601</span>:<span class="number">5601</span></span><br><span class="line"><span class="symbol">  logstash:</span></span><br><span class="line"><span class="symbol">    image:</span> logstash:<span class="number">6.4</span><span class="number">.1</span></span><br><span class="line"><span class="symbol">    container_name:</span> logstash</span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - <span class="meta-keyword">/lxb/</span>logstash/logstash-febs.conf:<span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/logstash/</span>pipeline/logstash.conf</span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - elasticsearch</span><br><span class="line"><span class="symbol">    links:</span></span><br><span class="line">      - elasticsearch:es</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="number">4560</span>:<span class="number">4560</span></span><br></pre></td></tr></table></figure>
<p> 切换到<code>/lxb/elk</code>目录下，使用如下命令启动： </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure>
<p> 第一次启动的时候，Docker需要拉取ELK镜像，过程可能稍慢，耐心等待即可。 </p>
<h2 id="Logstash中安装json-lines插件"><a href="#Logstash中安装json-lines插件" class="headerlink" title="Logstash中安装json_lines插件"></a>Logstash中安装json_lines插件</h2><p> 使用如下命令进入到Logstash容器中 </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it logstash <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>
<p> 切换到/bin目录，安装json_lines插件，然后退出： </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it logstash <span class="regexp">/bin/</span>bash</span><br><span class="line">cd <span class="regexp">/bin/</span></span><br><span class="line">logstash-plugin install logstash-codec-json_lines</span><br></pre></td></tr></table></figure>
<p> 使用浏览器访问<a href="http://localhost:5601/">http://localhost:5601</a>便可以看到Kibana管理界面</p>
<h1 id="修改微服务日志配置"><a href="#修改微服务日志配置" class="headerlink" title="修改微服务日志配置"></a>修改微服务日志配置</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h2><p> 日志配置文件<code>logback-spring.xml</code>里添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--输出到 logstash的 appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;logstash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.33.10:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;logstash&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>192.168.33.10:4560</code>对应我们刚刚搭建的Logstash地址。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nginx配置HTTPS和前端多目录部署</title>
    <url>/2020/09/28/%E4%BD%BF%E7%94%A8Nginx%E9%85%8D%E7%BD%AEHTTPS%E5%92%8C%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%9B%AE%E5%BD%95%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p> Nginx的实践 </p>
</blockquote>
<h1 id="开启Nginx的SSL模块"><a href="#开启Nginx的SSL模块" class="headerlink" title="开启Nginx的SSL模块"></a>开启Nginx的SSL模块</h1><p>Nginx如果未开启SSL模块，配置Https时提示如下错误：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] the <span class="string">&quot;ssl&quot;</span> parameter requires ngx_http_ssl_module <span class="keyword">in</span> <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/nginx.conf</span><br></pre></td></tr></table></figure>
<h1 id="Nginx配置HTTPS并做自动转发"><a href="#Nginx配置HTTPS并做自动转发" class="headerlink" title="Nginx配置HTTPS并做自动转发"></a>Nginx配置HTTPS并做自动转发</h1><ol>
<li>将证书放到服务器目录中</li>
<li>在server模块中配置HTTPS</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span>  xxxx.com;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">		<span class="attribute">ssl_certificate</span> cert/xxxx.com.pem; <span class="comment">#证书中pem文件地址</span></span><br><span class="line">		<span class="attribute">ssl_certificate_key</span> cert/xxxx.com.key;  <span class="comment">#证书中key文件地址</span></span><br><span class="line">		<span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">		<span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">		<span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">		<span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/local/test_project/admin-web/dist;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">	    <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>HTTP自动转发HTTPS</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  xxxx.com; <span class="comment">#多域名用空格分开</span></span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://$host<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">		</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="多目录部署前端项目"><a href="#多目录部署前端项目" class="headerlink" title="多目录部署前端项目"></a>多目录部署前端项目</h1><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">        <span class="keyword">listen</span> <span class="number">80</span>;</span><br><span class="line">        server_name  xxxx.com;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">location</span> /aaa &#123; </span><br><span class="line">                <span class="keyword">alias</span> /data/web-a/dist/; </span><br><span class="line">                <span class="keyword">index</span> <span class="keyword">index</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">location</span> /bbb &#123; </span><br><span class="line">                <span class="keyword">alias</span> /data/web-b/dist/;</span><br><span class="line">                <span class="keyword">index</span> <span class="keyword">index</span>.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Nginx中root和alias的区别"><a href="#Nginx中root和alias的区别" class="headerlink" title="Nginx中root和alias的区别"></a>Nginx中root和alias的区别</h1><p>root配置：nginx直接转发至 root后面地址+location 后面地址（返回的时候回带上location后面的地址）</p>
<p>alias配置： nginx直接转发至 alias的地址，不会加上location后的内容</p>
<p>注意：alias配置最后一定要 “/” 结尾 ，root随意</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spring AOP和自定义注解记录日志</title>
    <url>/2019/03/26/%E4%BD%BF%E7%94%A8Spring%20AOP%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标示该注解用于方法上</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="comment">//标示该注解可以在运行时通过反射找到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>@Retention<br>作用：标示注解在什么时候可见（运行时可见、仅在.class文件及源代码中可见、仅在源代码中可见），value可用参数有：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RetentionPolicy.RUNTIME</td>
<td>标示该注解可以再运行时通过反射找到（ORM框架许多注解使用了该参数）</td>
</tr>
<tr>
<td>RetentionPolicy.CLASS</td>
<td>标示该注解保存在.class文件中，但在运行时不能通过反射找到</td>
</tr>
<tr>
<td>RetentionPolicy.SOURSE</td>
<td>标示该注解只在源码中可见</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>@Target<br>作用：标示该注解用于注解什么元素（类、方法、变量等），value可用参数有：</li>
</ol>
<table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ElementType.PACKAGE</td>
<td>标示该注解用于注解包声明</td>
</tr>
<tr>
<td>ElementType.ANNOTATION_TYPE</td>
<td>标示该注解用于注解其他注解</td>
</tr>
<tr>
<td>ElementType.CONSTRUCTOR</td>
<td>标示该注解用于注解构造函数</td>
</tr>
<tr>
<td>ElementType.FIELD</td>
<td>标示该注解用于注解成员变量</td>
</tr>
<tr>
<td>ElementType.METHOD</td>
<td>标示该注解用于注解方法</td>
</tr>
<tr>
<td>ElementType.TYPE</td>
<td>标示该注解用于注解类，接口，枚举类型</td>
</tr>
<tr>
<td>ElementType.PARAMETER</td>
<td>标示该注解用于注解参数</td>
</tr>
<tr>
<td>ElementType.LOCAL_VARIABLE</td>
<td>标示该注解用于注解局部变量</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>value为操作信息</li>
</ol>
<h1 id="自定义切面"><a href="#自定义切面" class="headerlink" title="自定义切面"></a>自定义切面</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">@Slf4j</span><br><span class="line">public <span class="keyword">class</span> LogAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> long currentTime = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">Pointcut(<span class="string">&quot;@annotation(com.**.aop.log.Log)&quot;</span>)</span></span><br><span class="line">    public void log<span class="constructor">Pointcut()</span> &#123;</span><br><span class="line">        <span class="comment">// 该方法无方法体,主要为了让同类中其他方法使用此切入点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置环绕通知,使用在方法logPointcut()上注册的切入点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param joinPoint join point for advice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">Around(<span class="string">&quot;logPointcut()&quot;</span>)</span></span><br><span class="line">    public Object log<span class="constructor">Around(ProceedingJoinPoint <span class="params">joinPoint</span>)</span> throws Throwable &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        currentTime = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span><br><span class="line">        result = joinPoint.proceed<span class="literal">()</span>;</span><br><span class="line">        Log log = <span class="keyword">new</span> <span class="constructor">Log(<span class="string">&quot;INFO&quot;</span>,System.<span class="params">currentTimeMillis</span>()</span> - currentTime);</span><br><span class="line">        <span class="comment">//保存日志信息到数据库</span></span><br><span class="line">        logService.save(get<span class="constructor">Username()</span>, <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>get<span class="constructor">IP(RequestHolder.<span class="params">getHttpServletRequest</span>()</span>),joinPoint, log);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置异常通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param joinPoint join point for advice</span></span><br><span class="line"><span class="comment">     * @param e exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">AfterThrowing(<span class="params">pointcut</span> = <span class="string">&quot;logPointcut()&quot;</span>, <span class="params">throwing</span> = <span class="string">&quot;e&quot;</span>)</span></span><br><span class="line">    public void log<span class="constructor">AfterThrowing(JoinPoint <span class="params">joinPoint</span>, Throwable <span class="params">e</span>)</span> &#123;</span><br><span class="line">        Log log = <span class="keyword">new</span> <span class="constructor">Log(<span class="string">&quot;ERROR&quot;</span>,System.<span class="params">currentTimeMillis</span>()</span> - currentTime);</span><br><span class="line">        log.set<span class="constructor">ExceptionDetail(ThrowableUtil.<span class="params">getStackTrace</span>(<span class="params">e</span>)</span>.get<span class="constructor">Bytes()</span>);</span><br><span class="line">        logService.save(get<span class="constructor">Username()</span>, <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>get<span class="constructor">IP(RequestHolder.<span class="params">getHttpServletRequest</span>()</span>), (ProceedingJoinPoint)joinPoint, log);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get<span class="constructor">Username()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">SecurityUtils</span>.</span></span>get<span class="constructor">Username()</span>;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>在Controller方法上使用@Log<br>如：@Log(“查询用户”)</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Redis分布式锁解决并发问题</title>
    <url>/2019/05/06/%E4%BD%BF%E7%94%A8Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="synchronized处理并发"><a href="#synchronized处理并发" class="headerlink" title="synchronized处理并发"></a>synchronized处理并发</h2><p>首先，synchronized的确是一个解决办法，而且也很简单，在方法前面加一个synchronized关键字。</p>
<p>但是通过压测，发现请求变的很慢，因为：<br>synchronized就用一个锁把这个方法锁住了，每次访问这个方法，只会有一个线程，所以这就是它导致慢的原因。通过这种方式，保证这个方法中的代码都是单线程来处理，不会出什么问题。</p>
<p>同时，使用synchronized还是存在一些问题的，首先，它无法做到细粒度的控制，比如同一时间有秒杀A商品和B商品的请求，都进入到了这个方法，虽然秒杀A商品的人很多，但是秒杀B商品的人很少，但是即使是买B商品，进入到了这个方法，也会一样的慢。</p>
<p>最重要的是，它只适合单点的情况。如果以后程序水平扩展了，弄了个集群，很显然，负载均衡之后，不同的用户看到的结果一定是五花八门的。</p>
<p>所以，还是使用更好的办法，使用redis分布式锁。</p>
<h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h3 id="两个redis的命令"><a href="#两个redis的命令" class="headerlink" title="两个redis的命令"></a>两个redis的命令</h3><p>setnx key value ：setnx就是，如果没有这个key，那么就set一个key-value, 但是如果这个key已经存在，那么将不会再次设置，get出来的value还是最开始set进去的那个value.<br>网站中还专门讲到可以使用!SETNX加锁，如果获得锁，返回1，如果返回0，那么该键已经被其他的客户端锁定。<br>并且也提到了如何处理死锁。</p>
<p>参考地址：<a href="http://www.redis.cn/commands/setnx.html">http://www.redis.cn/commands/setnx.html</a></p>
<p>getset key value ：先通过key获取value，然后再将新的value set进去。</p>
<p>参考地址：<a href="http://www.redis.cn/commands/getset.html">http://www.redis.cn/commands/getset.html</a></p>
<h3 id="redis分布式锁的实现"><a href="#redis分布式锁的实现" class="headerlink" title="redis分布式锁的实现"></a>redis分布式锁的实现</h3><p>我们希望的，无非就是这一段代码，能够单线程的去访问，因此在这段代码之前给他加锁，相应的，这段代码后面要给它解锁：</p>
<p><img src="/2019/05/06/%E4%BD%BF%E7%94%A8Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/image_1cabec77q16dibn41a207mkpb19.png" alt="需要解决的代码图"></p>
<h4 id="引入redis依赖"><a href="#引入redis依赖" class="headerlink" title="引入redis依赖"></a>引入redis依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<h4 id="编写加锁和解锁的方法"><a href="#编写加锁和解锁的方法" class="headerlink" title="编写加锁和解锁的方法"></a>编写加锁和解锁的方法</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> RedisLock &#123;</span><br><span class="line">Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(<span class="params">this</span>.<span class="params">getClass</span>()</span>);</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁</span></span><br><span class="line"><span class="comment"> * @param key   商品id</span></span><br><span class="line"><span class="comment"> * @param value 当前时间+超时时间</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public boolean lock(String key, String value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.ops<span class="constructor">ForValue()</span>.set<span class="constructor">IfAbsent(<span class="params">key</span>, <span class="params">value</span>)</span>) &#123;     <span class="comment">//这个其实就是setnx命令，只不过在java这边稍有变化，返回的是boolea</span></span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免死锁，且只让一个线程拿到锁</span></span><br><span class="line">    String currentValue = redisTemplate.ops<span class="constructor">ForValue()</span>.get(key);</span><br><span class="line">    <span class="comment">//如果锁过期了</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Empty(<span class="params">currentValue</span>)</span><span class="operator"> &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>parse<span class="constructor">Long(<span class="params">currentValue</span>)</span> &lt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>) &#123;</span><br><span class="line">        <span class="comment">//获取上一个锁的时间</span></span><br><span class="line">        String oldValues = redisTemplate.ops<span class="constructor">ForValue()</span>.get<span class="constructor">AndSet(<span class="params">key</span>, <span class="params">value</span>)</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           只会让一个线程拿到锁</span></span><br><span class="line"><span class="comment">           如果旧的value和currentValue相等，只会有一个线程达成条件，因为第二个线程拿到的oldValue已经和currentValue不一样了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Empty(<span class="params">oldValues</span>)</span><span class="operator"> &amp;&amp; </span>oldValues.equals(currentValue)) &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @param value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public void unlock(String key, String value) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String currentValue = redisTemplate.ops<span class="constructor">ForValue()</span>.get(key);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>is<span class="constructor">Empty(<span class="params">currentValue</span>)</span><span class="operator"> &amp;&amp; </span>currentValue.equals(value)) &#123;</span><br><span class="line">            redisTemplate.ops<span class="constructor">ForValue()</span>.get<span class="constructor">Operations()</span>.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;『redis分布式锁』解锁异常，&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要有避免死锁的一步呢？<br>假设没有『避免死锁』这一步，结果在执行到下单代码的时候出了问题，毕竟操作数据库、网络、io的时候抛了个异常，这个异常是偶然抛出来的，就那么偶尔一次，那么会导致解锁步骤不去执行，这时候就没有解锁，后面的请求进来自然也或得不到锁，这就被称之为死锁。<br>而这里的『避免死锁』，就是给锁加了一个过期时间，如果锁超时了，就返回true，解开之前的那个死锁。</p>
<h4 id="下单代码中引入加锁和解锁，确保只有一个线程操作"><a href="#下单代码中引入加锁和解锁，确保只有一个线程操作" class="headerlink" title="下单代码中引入加锁和解锁，确保只有一个线程操作"></a>下单代码中引入加锁和解锁，确保只有一个线程操作</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RedisLock redisLock;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public String seckill(Integer id)throws RuntimeException &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    long time = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span> + <span class="number">1000</span>*<span class="number">10</span>;  <span class="comment">//超时时间：10秒，最好设为常量</span></span><br><span class="line"></span><br><span class="line">    boolean isLock = redisLock.lock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>, <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">time</span>)</span>);</span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;人太多了，换个姿势再试试~&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查库存</span></span><br><span class="line">    Product product = productMapper.find<span class="constructor">ById(<span class="params">id</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(product.get<span class="constructor">Stock()</span>==<span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;已经卖光&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//写入订单表</span></span><br><span class="line">    Order order=<span class="keyword">new</span> <span class="constructor">Order()</span>;</span><br><span class="line">    order.set<span class="constructor">ProductId(<span class="params">product</span>.<span class="params">getId</span>()</span>);</span><br><span class="line">    order.set<span class="constructor">ProductName(<span class="params">product</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    orderMapper.add(order);</span><br><span class="line">    <span class="comment">//减库存</span></span><br><span class="line">    product.set<span class="constructor">Price(<span class="params">null</span>)</span>;</span><br><span class="line">    product.set<span class="constructor">Name(<span class="params">null</span>)</span>;</span><br><span class="line">    product.set<span class="constructor">Stock(<span class="params">product</span>.<span class="params">getStock</span>()</span>-<span class="number">1</span>);</span><br><span class="line">    productMapper.update(product);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    redisLock.unlock(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">id</span>)</span>,<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">time</span>)</span>);</span><br><span class="line"></span><br><span class="line">    return find<span class="constructor">ProductInfo(<span class="params">id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能用redis分布式锁解决并发问题</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-雪花算法的原理和实现</title>
    <url>/2020/01/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的。整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p>
</blockquote>
<h1 id="雪花算法的原理"><a href="#雪花算法的原理" class="headerlink" title="雪花算法的原理"></a>雪花算法的原理</h1><p><img src="/2020/01/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1.jpg" alt="分布式唯一ID"></p>
<h2 id="雪花算法由四部分组成"><a href="#雪花算法由四部分组成" class="headerlink" title="雪花算法由四部分组成"></a>雪花算法由四部分组成</h2><ol>
<li><p>第一部分是1个bit，始终为0，不可用。</p>
<p>（因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。）</p>
</li>
<li><p>第二部分是41bit的时间戳，单位是毫秒。</p>
<p>（41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1 个毫秒值，换算成年就是表示 69 年的时间。）</p>
</li>
<li><p>第三部分是10bit的工作机器ID，由5个bit的机房ID和5个bit的机器ID组成。</p>
<p>（代表 2 ^ 5 个机房（32 个机房），每个机房里可以代表 2 ^ 5 个机器（32 台机器），也就是代表可以部署在1024台机器上。）</p>
</li>
<li><p>第四部分是12个bit的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000。</p>
<p>（12 bit 可以代表的最大正整数是 2 ^ 12 - 1 = 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。）</p>
</li>
</ol>
<h1 id="雪花算法的实现"><a href="#雪花算法的实现" class="headerlink" title="雪花算法的实现"></a>雪花算法的实现</h1><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="comment">// 机器标识位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">// 数据中心标识位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">// 机器ID最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> maxWorkerId = <span class="number">-1L</span> ^ (<span class="number">-1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">// 数据中心ID最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> maxDatacenterId = <span class="number">-1L</span> ^ (<span class="number">-1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="comment">// 毫秒内自增位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">// 机器ID偏左移12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">// 数据中心ID左移17位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">// 时间毫秒左移22位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> sequenceMask = <span class="number">-1L</span> ^ (<span class="number">-1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/* 上次生产id时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> lastTimestamp = <span class="number">-1L</span>;</span><br><span class="line">    <span class="comment">// 0，并发控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">// 数据标识id部分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = <span class="built_in">getDatacenterId</span>(maxDatacenterId);</span><br><span class="line">        <span class="keyword">this</span>.workerId = <span class="built_in">getMaxWorkerId</span>(datacenterId, maxWorkerId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param workerId</span></span><br><span class="line"><span class="comment">     *            工作机器ID</span></span><br><span class="line"><span class="comment">     * @param datacenterId</span></span><br><span class="line"><span class="comment">     *            序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="keyword">String</span>.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="keyword">String</span>.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个ID，核心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取当前时间戳，单位是毫秒</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = <span class="built_in">timeGen</span>();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="keyword">String</span>.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id</span></span><br><span class="line">        <span class="comment">// 这个时候就得把seqence序号给递增1，最多就是4096</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            <span class="comment">// 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，</span></span><br><span class="line">            <span class="comment">// 这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前毫秒内计数满了，则等待下一秒</span></span><br><span class="line">                timestamp = <span class="built_in">tilNextMillis</span>(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最近一次生成id的时间戳，单位是毫秒</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">// 这儿就是最核心的二进制位运算操作，生成一个64bit的id</span></span><br><span class="line">        <span class="comment">// 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；			将序号放最后12 bit</span></span><br><span class="line">        <span class="comment">// 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型</span></span><br><span class="line">        <span class="keyword">long</span> nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nextId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = <span class="keyword">this</span>.<span class="built_in">timeGen</span>();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = <span class="keyword">this</span>.<span class="built_in">timeGen</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.<span class="built_in">currentTimeMillis</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 maxWorkerId</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMaxWorkerId</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> maxWorkerId)</span> </span>&#123;</span><br><span class="line">        StringBuffer mpid = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">        mpid.<span class="built_in">append</span>(datacenterId);</span><br><span class="line">        <span class="keyword">String</span> name = ManagementFactory.<span class="built_in">getRuntimeMXBean</span>().<span class="built_in">getName</span>();</span><br><span class="line">        <span class="keyword">if</span> (!name.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * GET jvmPid</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            mpid.<span class="built_in">append</span>(name.<span class="built_in">split</span>(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * MAC + PID 的 hashcode 获取16个低位</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="keyword">return</span> (mpid.<span class="built_in">toString</span>().<span class="built_in">hashCode</span>() &amp; <span class="number">0xffff</span>) % (maxWorkerId + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 数据标识id部分</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">(<span class="keyword">long</span> maxDatacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> id = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress ip = InetAddress.<span class="built_in">getLocalHost</span>();</span><br><span class="line">            NetworkInterface network = NetworkInterface.<span class="built_in">getByInetAddress</span>(ip);</span><br><span class="line">            <span class="keyword">if</span> (network == null) &#123;</span><br><span class="line">                id = <span class="number">1L</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] mac = network.<span class="built_in">getHardwareAddress</span>();</span><br><span class="line">                id = ((<span class="number">0x000000FF</span> &amp; (<span class="keyword">long</span>) mac[mac.length - <span class="number">1</span>])</span><br><span class="line">                        | (<span class="number">0x0000FF00</span> &amp; (((<span class="keyword">long</span>) mac[mac.length - <span class="number">2</span>]) &lt;&lt; <span class="number">8</span>))) &gt;&gt; <span class="number">6</span>;</span><br><span class="line">                id = id % (maxDatacenterId + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (Exception e) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot; getDatacenterId: &quot;</span> + e.<span class="built_in">getMessage</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器</title>
    <url>/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p> 读《深入理解Java虚拟机》记录</p>
<p> 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
</blockquote>
<h1 id="Java内存哪个区域需要做垃圾收集？"><a href="#Java内存哪个区域需要做垃圾收集？" class="headerlink" title="Java内存哪个区域需要做垃圾收集？"></a>Java内存哪个区域需要做垃圾收集？</h1><blockquote>
<p>Java堆和方法区</p>
</blockquote>
<p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p>
<h1 id="如何确定对象已“死”"><a href="#如何确定对象已“死”" class="headerlink" title="如何确定对象已“死”"></a>如何确定对象已“死”</h1><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。</p>
<p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p><img src="/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/161641_uW2m_1983603.png" alt="161641_uW2m_1983603"></p>
<h2 id="引用补充"><a href="#引用补充" class="headerlink" title="引用补充"></a>引用补充</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。如果reference类型的数据中存储的数值是另一块内存的起始地址，那么这块内存就代表着一个引用。一个对象在这种状态下，只能有被引用和没有被引用两种状态。</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>创建方式</th>
<th>生存时长</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>new</td>
<td>GC不回收</td>
</tr>
<tr>
<td>软引用</td>
<td>SoftReference</td>
<td>内存足够GC不回收，不足回收</td>
</tr>
<tr>
<td>弱引用</td>
<td>WeakReference</td>
<td>GC必回收</td>
</tr>
<tr>
<td>虚引用</td>
<td>PhantomReference + ReferenceQueue</td>
<td>任何情况下都回收</td>
</tr>
</tbody>
</table>
<h2 id="对象的死亡过程"><a href="#对象的死亡过程" class="headerlink" title="对象的死亡过程"></a>对象的死亡过程</h2><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法（当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。）</li>
<li>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果还没有被引用，则会被回收。</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（HotSopt中的永久代）是没有垃圾收集的，java虚拟机规范中也没有要求需要对方法区实现垃圾收集。</p>
<blockquote>
<p>永久代(方法区)的垃圾收集主要回收两部分内容:废弃常量和无用的类</p>
</blockquote>
<ul>
<li><strong>废弃常量</strong>：假如一个字符串<code>“abc”</code>已经进入了常量池中，但是当前系统没有任何一个String对象是叫 做<code>“abc”</code>的，换句话说，就是没有任何String对象引用常量池中的<code>“abc”</code>常量，也没有其他 - 地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个<code>“abc”</code>常量就会被系 - 统清理出常量池。</li>
<li><strong>无用的类</strong>：同时满足下面3个条件的类（实例、类加载器被回收，<code>java.lang.Class</code>对象没有被引用）。</li>
</ul>
<ol>
<li>该类<strong>所有的实例</strong>都已经被回收，也就是Java<strong>堆中不存在该类的任何实例</strong>。</li>
<li>加载该类的<code>ClassLoader</code>已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><p><img src="/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/162639_lRPR_1983603.png" alt="162639_lRPR_1983603"></p>
<p>该算法分为两个阶段：首先标记处要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<p>缺点：</p>
<ol>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存,而不得不提前触发另一次垃圾收集动作</li>
</ol>
<h2 id="复制算法（新生代算法）-Copying"><a href="#复制算法（新生代算法）-Copying" class="headerlink" title="复制算法（新生代算法）(Copying)"></a>复制算法（新生代算法）(Copying)</h2><p><img src="/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/162929_kGQX_1983603.png" alt="162929_kGQX_1983603"></p>
<p>思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分。</p>
<p>优点</p>
<ul>
<li>避免了内存碎片的产生</li>
</ul>
<p>缺点</p>
<ul>
<li>将内存缩小为了原来的一半，浪费内存空间</li>
</ul>
<p>解决方法</p>
<ul>
<li>新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次使用<code>Eden</code>和其中一块<code>Survivor</code>。</li>
<li>在HotSpot里，考虑到大部分对象存活时间很短将内存分为<code>Eden</code>和两块<code>Survivor</code>，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用。</li>
</ul>
<p><img src="/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/163144_0sxV_1983603.png" alt="163144_0sxV_1983603"></p>
<h2 id="标记-整理算法（老年代算法）-Mark-Compact"><a href="#标记-整理算法（老年代算法）-Mark-Compact" class="headerlink" title="标记-整理算法（老年代算法）(Mark-Compact)"></a>标记-整理算法（老年代算法）(Mark-Compact)</h2><p><img src="/2020/11/10/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/163309_pPkR_1983603.png" alt="163309_pPkR_1983603"></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><ul>
<li>当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为<strong>新生代和老生代</strong>，根据<strong>各个年代采用适当的收集算法</strong>。</li>
<li>新生代存活率低，一般采用<strong>复制算法(Copying)</strong>。</li>
</ul>
<ul>
<li>老生代存活率高，一般采用 <strong>标记-清理(Mark-Sweep) 或者标记-整理(Mark-Compact)</strong> 进行回收。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/03/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>Hello,Blog!</strong></p>
<p><img src="/2019/03/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/1566915522.jpg" alt="窗外的世界"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库优化</title>
    <url>/2019/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="什么影响了数据库性能"><a href="#什么影响了数据库性能" class="headerlink" title="什么影响了数据库性能"></a>什么影响了数据库性能</h1><ul>
<li>sql查询速度</li>
<li>服务器硬件</li>
<li>网卡流量</li>
<li>磁盘IO</li>
<li>大表(10G)</li>
<li>大事务</li>
</ul>
<p>大表对DDL操作的影响</p>
<ul>
<li>建立索引需要很长时间</li>
<li>修改表结构需要长时间锁表</li>
</ul>
<p>如何处理数据库中的大表</p>
<ul>
<li>分库分表<br>把一张表分成多个小表<br>难点：<br>分表主键的选择<br>分表后跨分区数据的查询和统计</li>
<li>历史数据归档<br>难点：<br>归档时间点的选择<br>如何进行归档操作</li>
</ul>
<p>大事务的影响</p>
<ul>
<li>锁定太多的数据，造成大量的阻塞和锁超时</li>
<li>回滚所需的时间比较长</li>
<li>执行时间长，容易造成主从延迟</li>
</ul>
<p>RAID</p>
<h1 id="数据库索引优化策略"><a href="#数据库索引优化策略" class="headerlink" title="数据库索引优化策略"></a>数据库索引优化策略</h1><ol>
<li>索引列上不能使用表达式或函数</li>
<li>前缀索引和索引列的选择性</li>
<li>联合索引</li>
</ol>
<ul>
<li>经常会被使用到的列优先</li>
<li>选择性高的列优先</li>
<li>宽度小的列优先</li>
</ul>
<ol start="4">
<li>覆盖索引</li>
</ol>
<ul>
<li>优点</li>
<li>可以优化缓存，减少磁盘IO操作</li>
<li>可以减少随机IO，变随机IO操作变为顺序IO操作</li>
<li>可以避免对Innodb主键索引的二次查询</li>
<li>可以避免MyISAM表进行系统调用</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>使用令牌桶算法限流</title>
    <url>/2019/09/03/%E4%BD%BF%E7%94%A8%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流是对某一时间窗口内的请求数进行限制，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。常用的限流算法有令牌桶和和漏桶，而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。<br>在开发高并发系统时有三把利器用来保护系统：</p>
<ul>
<li>缓存：缓存的目的是提升系统访问速度和增大系统处理容量</li>
<li>降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行</li>
<li>限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理</li>
</ul>
<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:<br><img src="/2019/09/03/%E4%BD%BF%E7%94%A8%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81/1567475643.jpg" alt="漏桶算法示意图"><br>因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.</p>
<h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。<br>示意图如下:<br><img src="/2019/09/03/%E4%BD%BF%E7%94%A8%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81/1567475809.jpg" alt="令牌桶算法示意图"><br>令牌桶的好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量.</p>
<h1 id="令牌桶算法的使用"><a href="#令牌桶算法的使用" class="headerlink" title="令牌桶算法的使用"></a>令牌桶算法的使用</h1><h2 id="RateLimiter简介"><a href="#RateLimiter简介" class="headerlink" title="RateLimiter简介"></a>RateLimiter简介</h2><p>Google开源工具包Guava提供了限流工具类RateLimiter,该类基于令牌桶算法(Token Bucket)来完成限流,非常易于使用。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率.它支持两种获取permits接口,一种是如果拿不到立刻返回false,一种会阻塞等待一段时间看能不能拿到。</p>
<h2 id="RateLimiter的使用"><a href="#RateLimiter的使用" class="headerlink" title="RateLimiter的使用"></a>RateLimiter的使用</h2><ul>
<li>maven<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>23.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>实例</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的1表示每秒允许处理的量为1个</span></span><br><span class="line">    RateLimiter limiter = RateLimiter.<span class="built_in">create</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 请求RateLimiter, 超过permits会被阻塞</span></span><br><span class="line">        limiter.<span class="built_in">acquire</span>();</span><br><span class="line">        <span class="keyword">String</span> start = <span class="keyword">new</span> <span class="built_in">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;time:&quot;</span> + start + <span class="string">&quot;---------------&quot;</span> + +i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:11--------------<span class="string">-1</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:12--------------<span class="string">-2</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:13--------------<span class="string">-3</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:14--------------<span class="string">-4</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:15--------------<span class="string">-5</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:16--------------<span class="string">-6</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:17--------------<span class="string">-7</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:18--------------<span class="string">-8</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:19--------------<span class="string">-9</span></span><br><span class="line"><span class="keyword">time:</span>2019<span class="string">-09</span><span class="string">-03</span> 10:08:20--------------<span class="string">-10</span></span><br></pre></td></tr></table></figure>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaRateLimiterService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每秒控制5个许可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RateLimiter rateLimiter = RateLimiter.create(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> rateLimiter.<span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GuavaRateLimiterService guavaRateLimiterService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = <span class="meta-string">&quot;/sayHello&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> String sayHello() &#123;</span><br><span class="line">    <span class="keyword">if</span> (guavaRateLimiterService.tryAcquire()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;获取许可成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;获取许可失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
亦可用自定义注解+切面的方式实现</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入WEB请求过程</title>
    <url>/2020/07/21/%E6%B7%B1%E5%85%A5WEB%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p> 读《深入分析Java Web技术内幕》记录</p>
<p> 随着Web 2.0时代的到来，互联网的网络架构已经从传统的 <code>C/S</code> 架构转变为更加方便、快捷的 <code>B/S</code> 架构，B/S 架构大大简化了用户使用网络应用的难度，提高了用户体验。</p>
</blockquote>
<p><code>B/S</code> 架构带来了以下两方面的好处：</p>
<ul>
<li>客户端使用统一的浏览器（<code>Browser</code>）。由于浏览器具有统一性，不需要特殊的配置和网络连接。另外浏览器的交互特性使得用户使用它非常简便，且用户行为的可继承性非常强，也就是用户只要学会了上网，不管使用哪个应用，一旦学会了，便具备了使用其它任何互联网服务的经验。</li>
<li>服务端（<code>Server</code>）基于统一的 <code>HTTP</code>。和传统的 C/S 架构使用自定义的应用层协议不同。使用统一的 HTTP 简化了开发模式，并且基于 HTTP 的服务器又很多，如 <code>Apache</code>、<code>Nginx</code>、<code>Tomcat</code> 等，这些服务器可以直接拿来使用，不仅如此，连开发服务的通用框架也可以直接拿来使用，不需要单独开发，如 <code>Spring</code>、<code>Spring MVC</code>、<code>MyBatis</code> 等，我们只需关注服务的业务逻辑，同样简化了我们的开发工作。</li>
<li></li>
</ul>
<h1 id="B-S网络架构概述"><a href="#B-S网络架构概述" class="headerlink" title="B/S网络架构概述"></a>B/S网络架构概述</h1><p><code>B/S</code> 基于统一的应用层协议 <code>HTTP</code> 来交互数据，与大多数 <code>C/S</code> 互联网应用程序采用的长连接的交互模式不同。<code>HTTP</code> 采用无状态的短连接的通信方式，通常情况下，一次请求就完成了一次数据交互，然后这次通信连接就断开了。采用这种方式可以有效应对更多的用户请求。</p>
<p><img src="/2020/07/21/%E6%B7%B1%E5%85%A5WEB%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/1604037770(1" alt="1604037770(1)">.jpg)</p>
<p>如图所示：当用户在浏览器输入网址回发生如下操作：</p>
<ol>
<li>用户发起请求</li>
<li>DNS把域名解析为对应IP</li>
<li>根据IP找到对应的服务器发起一个get请求，有这个服务器决定返回默认的数据资源给访问的用户。 </li>
<li>服务器经过负载均衡等处理把数据返回给用户</li>
<li>如果浏览器解析数据时发现有静态资源，会发起另外的HTTP请求，这些请求可能会在CDN服务器上</li>
</ol>
<h1 id="如何发起一个请求"><a href="#如何发起一个请求" class="headerlink" title="如何发起一个请求"></a>如何发起一个请求</h1><p>这个问题简单又复杂，简单是指当我们在浏览器里数据一个 <code>URL</code> 时，按下回车键就发起了这个 <code>HTTP</code> 请求，很快就可以看到这个请求的返回结果。复杂是指不借助浏览器也能发起请求。</p>
<p>Java可借助工具包发起请求，Linux下可以使用curl+url就可以简单发起HTTP请求。查看http头信息，加上-I选项</p>
<h1 id="HTTP解析"><a href="#HTTP解析" class="headerlink" title="HTTP解析"></a>HTTP解析</h1><p>要理解 <code>HTTP</code>，最重要的是要熟悉 <code>HTTP</code> 中的 <code>HTTP Header</code>，它控制着数据的传输。最重要的是，它控制着浏览器的渲染行为和服务器的执行逻辑。例如，当服务器没有用户请求的数据时就会返回一个 404 状态码，告诉浏览器没有要请求的数据，通常浏览器会展示一个非常不愿意看到的个 “该页面不存在” 的错误信息。</p>
<p><strong>常见的 HTTP 请求头</strong></p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>指定客户端接收的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定可接受的编码（如 Accept-Encoding : gzip.deflate）</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>指定一种自然语言（如 Accept-Language : zh-cn）</td>
</tr>
<tr>
<td>Host</td>
<td>指定被请求资源的主机和端口号（如 Host : <a href="http://www.baidu.com）">www.baidu.com）</a></td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端将它的操作系统、浏览器和其它属性告诉服务端</td>
</tr>
<tr>
<td>Connection</td>
<td>指定当前连接是否保持（如 Connection : Keep-Alive）</td>
</tr>
</tbody>
</table>
<p><strong>常见的 HTTP 响应头</strong></p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server</td>
<td>服务器名称（如 Server : nginx/1.17.6）</td>
</tr>
<tr>
<td>Content-Type</td>
<td>发送给接收者的实体的类型（如 Content-Type : text/html;charset=GBK）</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>与 Accept-Encoding 对应，服务端采用的编码</td>
</tr>
<tr>
<td>Content-Language</td>
<td>与 Accept-Language 对应，资源所用的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>正文的长度</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>保持连接的时间（如 Keep-Alive : timeout=5）</td>
</tr>
</tbody>
</table>
<p><strong>常见的 HTTP 响应头</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>请求成功</td>
</tr>
<tr>
<td>302</td>
<td>临时跳转</td>
</tr>
<tr>
<td>400</td>
<td>客户端请求有语法错误，不能被服务器识别</td>
</tr>
<tr>
<td>403</td>
<td>服务器收到请求，但是拒绝提供服务，即没有权限</td>
</tr>
<tr>
<td>404</td>
<td>请求的资源不存在</td>
</tr>
<tr>
<td>500</td>
<td>服务器发生不可预期的错误</td>
</tr>
</tbody>
</table>
<h2 id="查看HTTP信息工具"><a href="#查看HTTP信息工具" class="headerlink" title="查看HTTP信息工具"></a>查看HTTP信息工具</h2><p>要看一个 <code>HTTP</code> 请求的请求头和响应头可以通过 F12 快捷键打开浏览器的调试工具查看，例如我们正在访问 <a href="http://www.baidu.com，按下">www.baidu.com，按下</a> F12 并打开 <code>Network</code> 调试栏可以看到以下 <code>HTTP Header</code> 内容</p>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><p>当浏览一个网页发现有异常时，通常要考虑的就是是不是浏览器做了缓存，所以一般的做法就是按 <code>Ctrl + F5</code> 组合键重新请求一次这个页面，这样的话请求的肯定是最新的页面。因为按 <code>Ctrl + F5</code> 组合键会直接向目标 <code>URL</code> 发送请求，而不会使用浏览器缓存的数据。</p>
<p>按 <code>Ctrl + F5</code> 组合键刷新页面后，会发现在 <code>HTTP</code> 的请求头中通常多了两个参数，分别是 <code>Cache-Control:no-cache</code> 和 <code>Pragma:no-cache</code>，该参数作用就是请求内容不会被缓存</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>Cache-Control/Pragma</th>
<th>Expires</th>
<th>Last-Modified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>值</td>
<td>Public：所有内容都被缓存，在响应头设置。<br>Private：内容只缓存到私有缓存中，在响应头设置。<br>No-cache: 所有内容不会被缓存<br>No-store:所有内容不会被缓存到缓存或Intent临时文件中<br>Must-revalidation/proxy-revalidation:如果缓存内容失败，请求必须发送到服务器进行重新验证<br>Max-age=xx:缓存内容在xxx秒后失效，这个只在HTTP1.1可用。</td>
<td>通常使用格式是：Expries：Sat,25 Feb 2012 12:22:17 GMT 后面跟着一个日期和时间</td>
<td>Last-Modified:时间<br>Etag:编号</td>
</tr>
<tr>
<td>含义</td>
<td>用于指定所有缓存机制在整个请求响应链中必须服从的指令。</td>
<td>超过这个时间值，缓存的内容将失效。也就是浏览器在发出请求之前检查这个页面这个字段,看该页面是否已经过期了，过期了就重新向服务器发起请求。</td>
<td>Last-Modified字段一般用于一个服务器上的资源最后修改时间，资源可以是静态（静态内容自动加上Last-Modified）或者动态的内容（Servlet提供一个getLastModified方法用于检查某个动态内容是否已经更新），通过这个最后修改时间可以判断当前请求的资源是否最新的。<br>Etag这个字段让服务器给每个一个页面分配一个唯一编号，区分当前这个页面是否最新的。</td>
</tr>
</tbody>
</table>
<h1 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h1><p><img src="/2020/07/21/%E6%B7%B1%E5%85%A5WEB%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/微信截图_20201030144022.png" alt="微信截图_20201030144022"></p>
<p>如上图所示，当用户在浏览器输入地址是，DNS解析将会有将近10个步骤：</p>
<ol>
<li><p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存有，这个解析就将结束。</p>
</li>
<li><p>如果用户的浏览器中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。即查找本机系统中的hosts文件，如查找到，解析也将结束</p>
</li>
<li><p>怎么知道域名服务器呢？在我们的网络配置中有DNS服务器的地址，也就是LDNS（本地域名服务器）</p>
</li>
<li><p>80%的域名解析在第三步的时候就完成了，如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析。</p>
</li>
<li><p>根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等，全球只有13台左右）地址</p>
</li>
<li><p>此时LDNS再发送请求给上一步返回的gTLD</p>
</li>
<li><p>接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器</p>
</li>
<li><p>Name Server根据映射关系表找到目标ip，返回给LDNS</p>
</li>
<li><p>LDNS缓存这个域名和对应的ip</p>
</li>
<li><p>LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</p>
</li>
</ol>
<h1 id="CDN工作机制"><a href="#CDN工作机制" class="headerlink" title="CDN工作机制"></a>CDN工作机制</h1><p>CDN内容分布网络（ContentDelivery Network）是构筑在现有的Internet上的一种先进的流量分配网络。其目的是在现有的Internet上增加一层新的网络架构，将网站的内容发布到最接近用户的服务器，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 一个CND架构=镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）。</p>
<p>技术原理：在 <code>CDN</code> 的 <code>DNS</code> 解析中通过动态的链路探测来寻找回源最好的一条路径，然后通过 DNS 的调度将所有请求调度到选定的这条路径上回源，从而加速用户访问的效率。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程知识总结</title>
    <url>/2019/05/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="网络编程简述"><a href="#网络编程简述" class="headerlink" title="网络编程简述"></a>网络编程简述</h1><p>网络编程就是在两个或两个以上的设备(例如计算机)之间传输数据，中间传输为物理线路的作用。</p>
<h1 id="网络通信要素"><a href="#网络通信要素" class="headerlink" title="网络通信要素"></a>网络通信要素</h1><h2 id="IP地址（InetAddress）"><a href="#IP地址（InetAddress）" class="headerlink" title="IP地址（InetAddress）"></a>IP地址（InetAddress）</h2><p> 特点：<br>          网络中的设备标识。<br>          不易记忆，但是可用主机名。<br>          本地回环地址127.0.0.1  主机名localhost。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>数据要发送到对方指定的应用程序上，为了标识这些应用程序，给这些网络应用程序都用数字进行标识。为了方便称呼这个数字，把它称为端口，是逻辑端口。<br> 特点：<br>          用于标识进程的逻辑地址。<br>          有效端口号：0—65535，其中0—1024系统使用或保留端口。</p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p> 传输协议：通讯的规则。</p>
<h3 id="TCP-传输控制协议-方式"><a href="#TCP-传输控制协议-方式" class="headerlink" title="TCP(传输控制协议)方式"></a>TCP(传输控制协议)方式</h3><p>TCP方式就类似于拨打电话，使用该种方式进行网络通讯时，需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据<br>特点：<br>          建立连接，形成传输数据的通道。<br>          在连接中可以进行大数据传输。<br>          通过三次握手完成连接，是可靠协议<br>          必须建立连接，效率和降低。</p>
<h3 id="UDP-用户数据报协议-方式"><a href="#UDP-用户数据报协议-方式" class="headerlink" title="UDP(用户数据报协议)方式"></a>UDP(用户数据报协议)方式</h3><p>UDP方式就类似于发送短信，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得<br>特点：<br>          将数据及源和目的封装在数据包中，不需要建立连接<br>          每个数据报的大小限制在64K内。<br>          不需要建立连接，速度快。<br>          因无连接，是不可靠协议。</p>
<p>这两种传输方式都是实际的网络编程中进行使用，重要的数据一般使用TCP方式进行数据传输，而大量的非核心数据则都通过UDP方式进行传递，在一些程序中甚至结合使用这两种方式进行数据的传递。由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而且传输时产生的数据量要比UDP稍微大一些。</p>
<h3 id="UDP和TCP协议的区别"><a href="#UDP和TCP协议的区别" class="headerlink" title="UDP和TCP协议的区别"></a>UDP和TCP协议的区别</h3><p>​          使用UDP时，每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 </p>
<p>​          对于TCP协议，由于它是一个面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中多了一个连接建立的时间 。</p>
<p>​          使用UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 </p>
<p>​          TCP没有这方面的限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大量的数据。 </p>
<p>​          UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。 </p>
<p>​          TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据 。</p>
<p>​          TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。 </p>
<p>​          相比之下UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序 。</p>
<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>​                             1.OSI参考模型                                2.TCP/IP参考模型</p>
<p><img src="/2019/05/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/983980-20161121173924409-1128983178.png" alt="模型参考图"></p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>特点：<br>​          Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。<br>​          Socket就是为网络服务提供的一种机制。<br>​          通信的两端都有Socket。<br>​          网络通信其实就是Socket之间的通信。<br>​          数据在两个Socket之间通过IO传输。</p>
<h1 id="HTTP-和-WebSocket的区别"><a href="#HTTP-和-WebSocket的区别" class="headerlink" title="HTTP 和 WebSocket的区别"></a>HTTP 和 WebSocket的区别</h1><ol>
<li>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。</li>
</ol>
<p>　　http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p>
<ol start="2">
<li>WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。</li>
</ol>
<p>　　建立了WebSocket之后服务器不必在浏览器发送request请求之后才能发送信息到浏览器。这时的服务器已有主动权想什么时候发就可以发送信息到服务器。而且信息当中不必在带有head的部分信息了与http的长链接通信来说，这种方式，不仅能降低服务器的压力。而且信息当中也减少了部分多余的信息。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <url>/2020/12/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote>
<p> 读《深入理解Java虚拟机》记录<br> 所谓的「虚拟机字节码执行引擎」其实就是 JVM 根据 Class 文件中给出的字节码指令，基于栈解释器的一种执行机制。通俗点来说，也就是 JVM 解析字节码指令，输出运行结果的一个过程。</p>
</blockquote>
<h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>详见：<a href="https://linxiaobaixcg.github.io/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/">https://linxiaobaixcg.github.io/2020/10/29/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</a></p>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p><strong>Class文件的编译过程并不包含传统编译的连接阶段，Class文件中方法都是以符号引用的形式存储的，而不是方法的入口地址。这个特性使得Java具有强大的动态扩展的能力，但同时也增加了Java方法调用过程的复杂性</strong>，因为方法需要在类加载期间甚至是运行时才能确定真正的入口地址，即将符号引用转换为直接引用。</p>
<p>这里所说的方法调用并不等同于方法执行，这个阶段的唯一目的就是确定被调用方法的版本，还不涉及方法内部的具体运行过程。对于方法的版本，需要解释的就是由于重载与多态的存在，一个符号引用可能对应多个真正的方法，这就是方法的版本。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的过程就是在类加载过程中的解析阶段。在类加载过程中，我们知道解析阶段就是将符号引用转换为直接引用的过程，那个时候的解析阶段解析了类或接口、字段、类方法和接口方法。在这个阶段，会将Class文件中的一部分方法的符号引用解析为直接引用，这种解析能够成立的条件是，方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的电泳版本在运行期间是不变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。</p>
<p>在Java虚拟机中提供了5条方法调用的字节码指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法；</li>
<li>invokespecial：调用实例构造器<init>方法、私有方法和父类方法；</init></li>
<li>invokevirtual：调用所有的虚方法；</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象；</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑都是固化在Java虚拟机中的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>解析调用是一个静态的过程，在编译期间就已经完全确定，在类加载的解析阶段就会把涉及到的符号引用转化为直接引用，不会延迟到运行期再去完成。而分派调用则既可能是静态的也可能是动态的，根据分派的宗量数可以分为单分派和多分派，这两类分派方法的两两组合就构成了静态单分派、静态多分派、动态单分派和动态多分派四种。</p>
<h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>Java是一门面向对象的语言，它具备三个主要的面向对象特征：继承、封装和多态。正是由于多态的存在，使得在判断方法调用的版本的时候会存在选择的问题，这也正是分派阶段存在的原因。这一部分会在Java虚拟机的角度介绍<strong>“重载”和“重写”的底层实现原理(重载为静态分派,也是多分派; 重写是动态分派,也是单分派)。</strong></p>
<h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><p>首先看看下面这个代码，涉及到了正是继承中的重载问题。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">sayHello</span>(<span class="params">Human human</span>)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">sayHello</span>(<span class="params">Man man</span>)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,gentleman!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">sayHello</span>(<span class="params">Woman woman</span>)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,lady!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">		Human man=<span class="keyword">new</span> Man();</span><br><span class="line">		Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">		StaticDispatch sr=<span class="keyword">new</span> StaticDispatch();</span><br><span class="line">		sr.sayHello(man);</span><br><span class="line">		sr.sayHello(woman);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p>hello,guy!<br>hello,guy!</p>
<p>这是考察多态的经典问题。要想了解这个问题的本质，需要知道这两个概念：静态类型和实际类型。</p>
<p>什么是静态类型？静态类型可以理解为变量声明的类型，比如上面的man这个变量，它的静态类型就是Human。而实际类型就是创建这个对象的类型，man这个变量的实际类型就是Man。这两种类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会发生变化，并且最终的静态类型是编译期间可知的。而实际类型变化的结果在运行期才可以确定，编译器在编译程序时并不知道一个对象的实际类型是什么。</p>
<h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>在了解了静态分派后，再看看动态分派的过程，它和多态性的另一个重要的特性重写有关。下面用一个例子来介绍，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello gentleman&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello lady&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Human man=<span class="keyword">new</span> Man();</span><br><span class="line">		Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">		woman.sayHello();</span><br><span class="line">		man=<span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>Hello gentleman<br>Hello lady<br>Hello lady</p>
<p>这个结果对于熟悉Java面向对象编程的人来说都不陌生。这里要说明的是，虚拟机是如何知道要调用哪个版本的。</p>
<p>显然这不是根据静态类型决定的，因为两个对象的静态类型都是Human。但是调用的结果却不同，这是因为这两个对象的实际类型不同。所以，Java虚拟机是通过实际类型来判断要调用方法的版本的。</p>
<h2 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h2><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是基于多个宗量。</p>
<p>下面以一个例子介绍一下单分派或多分派，代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Coca</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">like</span>(<span class="params">Pepsi p</span>)</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Father likes pepsi&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">like</span>(<span class="params">Coca c</span>)</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Father likes coca&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">like</span>(<span class="params">Pepsi p</span>)</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Son likes pepsi&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">like</span>(<span class="params">Coca c</span>)</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Son likes coca&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">		Father father=<span class="keyword">new</span> Father();</span><br><span class="line">		Son son=<span class="keyword">new</span> Son();</span><br><span class="line">		father.like(<span class="keyword">new</span> Coca());</span><br><span class="line">		son.like(<span class="keyword">new</span> Pepsi());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>Father likes coca<br>Son likes pepsi</p>
<p>这个结果没有什么意外的地方，主要是看一下虚拟机是如何确定方法调用的版本的。</p>
<p>先看看静态分派过程，这个时候选择的依据有两个：静态类型是Father还是Son，方法参数是Pepsi还是Coca。这次选择产生了两个invokevirtual指令，两条指令的参数分别为常量池中指向Father.like(Coca)和Father.like(Pepsi)方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
<p>然后看看运行时虚拟机的选择，即动态分派过程。在执行son.like(new Pepsi())时，也就是说在执行invokevirtual指令时，由于编译期间已经决定目标方法的签名必须是like(Pepsi)，虚拟机此时不会关心传递过来的参数是什么，因为这时参数的静态类型、实际类型都对方法的选择不会构成影响，唯一有影响的就是方法的接收者的实际类型是Father还是Son。因为只有一个宗量，所以Java的动态分派属于单分派。</p>
<h2 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h2><p>由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在invokeinterface执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。下图就是前面代码的虚方法表结构：<br><img src="/2020/12/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/20160606200822089.png" alt="20160606200822089"></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。在上图中，Son重写了Father的全部方法，所以Son的方法表替换了父类的地址。但是Son和Father都没有重写Object的方法，所以方法表都指向了Object的数据类型。</p>
<p>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p>
<p>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载机制</title>
    <url>/2020/12/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p> 读《深入理解Java虚拟机》记录</p>
<p> 虚拟机把类的数据从Class文件(这里的Class文件可以是javac编译成的class文件，也可以是反射或者动态代理生成的class二进制流，或者网络传输的二进制流等等)加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制。</p>
</blockquote>
<h1 id="虚拟机什么时候才会加载Class文件并初始化类呢？（类加载的时机）"><a href="#虚拟机什么时候才会加载Class文件并初始化类呢？（类加载的时机）" class="headerlink" title="虚拟机什么时候才会加载Class文件并初始化类呢？（类加载的时机）"></a>虚拟机什么时候才会加载Class文件并初始化类呢？（类加载的时机）</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段。其中准备、验证、解析三个部分统称为连接(Linking)。</p>
<p><img src="/2020/12/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1900685-5b9f351d3bc5b208.jpg" alt="1900685-5b9f351d3bc5b208"></p>
<p>加载、验证、准备、初始化和卸载5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以再初始化阶段后再开始，这是为了支持Java语言的运行时绑定(也称动态绑定或晚期绑定)。注意：类的加载过程必须按照这种顺序<strong>按部就班</strong>地开始，而不是<strong>按部就班</strong>地进行或完成，因为这些阶段通常都是相互交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p>
<p>Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始），具体5种情况如下</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<h1 id="虚拟机加载一个Class文件要经历那些具体的步骤呢？-类加载的过程"><a href="#虚拟机加载一个Class文件要经历那些具体的步骤呢？-类加载的过程" class="headerlink" title="虚拟机加载一个Class文件要经历那些具体的步骤呢？(类加载的过程)"></a>虚拟机加载一个Class文件要经历那些具体的步骤呢？(类加载的过程)</h1><h2 id="加载：查找并加载类的二进制数据"><a href="#加载：查找并加载类的二进制数据" class="headerlink" title="加载：查找并加载类的二进制数据"></a>加载：查找并加载类的二进制数据</h2><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ol>
<p>注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。</p>
<p>  相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>  加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在<code>Java堆中也创建一个java.lang.Class类的对象</code>，这样便可以通过该对象访问方法区中的这些数据。</p>
<h2 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
<p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p>
<p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：public static int value = 3；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p>
</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">· 这里还需要注意如下几点：</span><br><span class="line">· 对基本数据类型来说，对于类变量（<span class="keyword">static</span>）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</span><br><span class="line">· 对于同时被<span class="keyword">static</span>和<span class="keyword">final</span>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<span class="keyword">final</span>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</span><br><span class="line">· 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<span class="literal">null</span>。</span><br><span class="line">· 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为： public static final int value = 3；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p>
</li>
</ol>
<h2 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<p><strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量。</p>
<p><strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li><p>声明类变量是指定初始值</p>
</li>
<li><p>使用静态代码块为类变量指定初始值</p>
<p>JVM初始化步骤</p>
</li>
<li><p>假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
</li>
<li><p>假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
</li>
<li><p>假如类中有初始化语句，则系统依次执行这些初始化语句</p>
</li>
</ol>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li><p>执行了System.exit()方法</p>
</li>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p>
</li>
</ul>
<h1 id="虚拟机如何加载一个Class文件呢？-Java类加载的方式：类加载器、双亲委派机制"><a href="#虚拟机如何加载一个Class文件呢？-Java类加载的方式：类加载器、双亲委派机制" class="headerlink" title="虚拟机如何加载一个Class文件呢？(Java类加载的方式：类加载器、双亲委派机制)"></a>虚拟机如何加载一个Class文件呢？(Java类加载的方式：类加载器、双亲委派机制)</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器：虚拟机设计团队将类加载阶段的类加载过程中的加载动作，放到虚拟机外部实现，也就是可以运行开发人员自己觉得如何获取所需要的类，这个加载动作的实现就是类加载器。</p>
<p>类加载器的层次关系如下图所示：</p>
<p><img src="/2020/12/08/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/331425-20160621125944459-1013316302.jpg" alt="331425-20160621125944459-1013316302"></p>
<p>站在虚拟机的角度来看，只有两种加载器，一种是启动类加载器，是有C++语言实现的，是虚拟机的一部分；另外一部分是所有的其他类加载器，由Java语言编写，独立于虚拟机之外，都继承自抽象类java.lang.ClassLoader。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器</strong>：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
<p><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
<p><strong>应用程序类加载器</strong>：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p>1）在执行非置信代码之前，自动验证数字签名。</p>
<p>2）动态地创建符合用户特定需要的定制化构建类。</p>
<p>3）从特定的场所取得java class，例如数据库中和网络中。</p>
<p>JVM类加载机制：</p>
<ul>
<li><p>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
</li>
<li><p>父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
</li>
<li><p>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
</li>
</ul>
<p><strong>类的加载</strong></p>
<p>类加载有三种方式：</p>
<ol>
<li><p>命令行启动应用时候由JVM初始化加载</p>
</li>
<li><p>通过Class.forName()方法动态加载</p>
</li>
<li><p>通过ClassLoader.loadClass()方法动态加载</p>
</li>
</ol>
<p><strong>Class.forName()和ClassLoader.loadClass()区别？</strong></p>
<p>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p>
<p>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p>
<p><strong>注：</strong></p>
<p>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><strong>双亲委派机制:</strong></p>
<ol>
<li><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
</li>
<li><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
</li>
<li><p>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p>
</li>
<li><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</li>
</ol>
<p><strong>双亲委派模型意义：</strong></p>
<ul>
<li><p>系统类防止内存中出现多份同样的字节码</p>
</li>
<li><p>保证Java程序安全稳定运行</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>技术书籍</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Spring Boot异步上传文件提示无法找到文件问题</title>
    <url>/2021/01/20/%E8%A7%A3%E5%86%B3Spring%20Boot%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>使用Spring Boot上传文件进行操作时，为了减少客户端等待耗时，选择使用异步实现后报</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">java.io.FileNotFoundException</span>: <span class="function"><span class="title">xxx</span>(系统找不到指定的文件。)</span></span><br></pre></td></tr></table></figure>
<p>根据提示在找到临时文件路径，确实在文件夹里找不到对应文件</p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>表面看以为是临时文件创建失败或者文件夹不存在，真正原因在于异步操作上传时，主线程请求流已经关闭了，并把临时目录下的临时文件删除了，所以业务中才会报找不到文件异常。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>可以选择在主线程保存文件流数据</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>解读SPDY协议</title>
    <url>/2019/08/26/%E8%A7%A3%E8%AF%BBSPDY%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SPDY（读作“SPeeDY”）是Google开发的基于TCP的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。它是对HTTP协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议通过压缩、多路复用和优先级来缩短加载时间。</p>
<ul>
<li>注：该协议已弃用，可探究其特性和其底层原理进行学习<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1></li>
<li>单个TCP连接支持并发的HTTP请求。</li>
<li>压缩报头和去掉不必要的头部来减少当前HTTP使用的带宽。</li>
<li>定义一个容易实现，在服务器端高效率的协议。通过减少边缘情况、定义易解析的消息格式来减少HTTP的复杂性。</li>
<li>强制使用SSL，让SSL协议在现存的网络设施下有更好的安全性和兼容性。</li>
<li>允许服务器在需要时发起对客户端的连接并推送数据。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SSL层上增加SPDY会话层<br><img src="/2019/08/26/%E8%A7%A3%E8%AF%BBSPDY%E5%8D%8F%E8%AE%AE/d000baa1cd11728b46037ae3cafcc3cec2fd2cc0.png" alt="SPDY原理图"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统中常见的加密算法和实现</title>
    <url>/2020/10/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p> 数字签名、信息加密是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、oauth 等等，不同的应用场景也会需要使用到不同的签名加密算法。</p>
</blockquote>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p><strong>数字签名</strong>，简单来说就是通过提供 <strong>可鉴别</strong> 的 <strong>数字信息</strong> 验证 <strong>自身身份</strong> 的一种方式。一套 <strong>数字签名</strong> 通常定义两种 <strong>互补</strong> 的运算，一个用于 <strong>签名</strong>，另一个用于 <strong>验证</strong>。分别由 <strong>发送者</strong> 持有能够 <strong>代表自己身份</strong> 的 <strong>私钥</strong> (私钥不可泄露),由 <strong>接受者</strong> 持有与私钥对应的 <strong>公钥</strong> ，能够在 <strong>接受</strong> 到来自发送者信息时用于 <strong>验证</strong> 其身份。<br><img src="/2020/10/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/16493f2bfa18df72.png" alt="16493f2bfa18df72"></p>
<blockquote>
<p><strong>注意</strong>：图中 <strong>加密过程</strong> 有别于 <strong>公钥加密</strong>，<strong>签名</strong> 最根本的用途是要能够唯一 <strong>证明发送方的身份</strong>，防止 <strong>中间人攻击</strong>、<code>CSRF</code> <strong>跨域身份伪造</strong>。基于这一点在诸如 <strong>设备认证</strong>、<strong>用户认证</strong>、<strong>第三方认证</strong> 等认证体系中都会使用到 <strong>签名算法</strong> (彼此的实现方式可能会有差异)。</p>
</blockquote>
<h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>数据加密的基本过程，就是对原来为明文的文件或数据按某种算法进行处理，使其成为 不可读的一段代码，通常称为“密文”。通过这样的途径，来达到保护数据不被 非法人窃取、阅读的目的。</p>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>加密的逆过程为解密，即将该编码信息转化为其原来数据的过程。</p>
<h1 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h1><p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p>
<blockquote>
<p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p>
</blockquote>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p><strong>对称加密算法</strong> 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，<strong>发送</strong> 和 <strong>接收</strong> 双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。这就要求加密和解密方事先都必须知道加密的密钥。</p>
<p><img src="/2020/10/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/16493f2bfa02dbcd.png" alt="16493f2bfa02dbcd"></p>
<ol>
<li>数据加密过程：在对称加密算法中，<strong>数据发送方</strong> 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</li>
<li>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</li>
</ol>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><strong>非对称加密算法</strong>，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p>
<p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。<br><img src="/2020/10/10/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/16493f2bfa06e955.png" alt="16493f2bfa06e955"></p>
<ol>
<li>如果使用<strong>公钥</strong>对数据<strong>进行加密</strong>，只有用对应的<strong>私钥</strong>才能<strong>进行解密</strong>。</li>
<li>如果使用<strong>私钥</strong>对数据<strong>进行加密</strong>，只有用对应的<strong>公钥</strong>才能<strong>进行解密</strong>。</li>
</ol>
<blockquote>
<p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p>
</blockquote>
<h1 id="常见的签名加密算法"><a href="#常见的签名加密算法" class="headerlink" title="常见的签名加密算法"></a>常见的签名加密算法</h1><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p><code>MD5</code> 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，<code>MD5</code> 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，<code>MD5</code> 都会输出长度为 <code>128bits</code> 的一个串 (通常用 <code>16</code> <strong>进制</strong> 表示为 <code>32</code> 个字符)。</p>
<h2 id="SHA1算法"><a href="#SHA1算法" class="headerlink" title="SHA1算法"></a>SHA1算法</h2><p><code>SHA1</code> 是和 <code>MD5</code> 一样流行的 <strong>消息摘要算法</strong>，然而 <code>SHA1</code> 比 <code>MD5</code> 的 <strong>安全性更强</strong>。对于长度小于 <code>2 ^ 64</code> 位的消息，<code>SHA1</code> 会产生一个 <code>160</code> 位的 <strong>消息摘要</strong>。基于 <code>MD5</code>、<code>SHA1</code> 的信息摘要特性以及 <strong>不可逆</strong> (一般而言)，可以被应用在检查 <strong>文件完整性</strong> 以及 <strong>数字签名</strong> 等场景。</p>
<h2 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h2><p><code>HMAC</code> 是密钥相关的 <strong>哈希运算消息认证码</strong>（Hash-based Message Authentication Code），<code>HMAC</code> 运算利用 <strong>哈希算法</strong> (<code>MD5</code>、<code>SHA1</code> 等)，以 <strong>一个密钥</strong> 和 <strong>一个消息</strong> 为输入，生成一个 <strong>消息摘要</strong> 作为 <strong>输出</strong>。</p>
<p><code>HMAC</code> <strong>发送方</strong> 和 <strong>接收方</strong> 都有的 <code>key</code> 进行计算，而没有这把 <code>key</code> 的第三方，则是 <strong>无法计算</strong> 出正确的 <strong>散列值</strong>的，这样就可以 <strong>防止数据被篡改</strong>。</p>
<h2 id="AES-DES-3DES算法"><a href="#AES-DES-3DES算法" class="headerlink" title="AES/DES/3DES算法"></a>AES/DES/3DES算法</h2><p><code>AES</code>、<code>DES</code>、<code>3DES</code> 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong>。常用的有 <code>AES128</code>、<code>AES192</code>、<code>AES256</code> (默认安装的 <code>JDK</code> 尚不支持 <code>AES256</code>，需要安装对应的 <code>jce</code> 补丁进行升级 <code>jce1.7</code>，<code>jce1.8</code>)。</p>
<h4 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h4><p><code>DES</code> 加密算法是一种 <strong>分组密码</strong>，以 <code>64</code> 位为 <strong>分组对数据</strong> 加密，它的 <strong>密钥长度</strong> 是 <code>56</code> 位，<strong>加密解密</strong> 用 <strong>同一算法</strong>。</p>
<p><code>DES</code> 加密算法是对 <strong>密钥</strong> 进行保密，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 <strong>相同密钥</strong> 的人才能解读由 <code>DES</code>加密算法加密的密文数据。因此，破译 <code>DES</code> 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 <code>56</code> 位长度的 <strong>密钥</strong> 来说，如果用 <strong>穷举法</strong> 来进行搜索的话，其运算次数为 <code>2 ^ 56</code> 次。</p>
<h4 id="3DES算法"><a href="#3DES算法" class="headerlink" title="3DES算法"></a>3DES算法</h4><p>是基于 <code>DES</code> 的 <strong>对称算法</strong>，对 <strong>一块数据</strong> 用 <strong>三个不同的密钥</strong> 进行 <strong>三次加密</strong>，<strong>强度更高</strong>。</p>
<h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><code>AES</code> 加密算法是密码学中的 <strong>高级加密标准</strong>，该加密算法采用 <strong>对称分组密码体制</strong>，密钥长度的最少支持为 <code>128</code> 位、 <code>192</code> 位、<code>256</code> 位，分组长度 <code>128</code> 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 <strong>区块加密标准</strong>。</p>
<h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p><code>RSA</code> 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。<code>RSA</code> 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 <code>ISO</code> 推荐为公钥数据加密标准。</p>
<h2 id="ECC算法"><a href="#ECC算法" class="headerlink" title="ECC算法"></a>ECC算法</h2><p><code>ECC</code> 也是一种 <strong>非对称加密算法</strong>，主要优势是在某些情况下，它比其他的方法使用 <strong>更小的密钥</strong>，比如 <code>RSA</code> <strong>加密算法</strong>，提供 <strong>相当的或更高等级</strong> 的安全级别。不过一个缺点是 <strong>加密和解密操作</strong> 的实现比其他机制 <strong>时间长</strong> (相比 <code>RSA</code> 算法，该算法对 <code>CPU</code> 消耗严重)。</p>
<h1 id="各种加密算法对比"><a href="#各种加密算法对比" class="headerlink" title="各种加密算法对比"></a>各种加密算法对比</h1><h2 id="散列算法比较"><a href="#散列算法比较" class="headerlink" title="散列算法比较"></a>散列算法比较</h2><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">安全性</th>
<th style="text-align:left">速度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SHA-1</td>
<td style="text-align:left">高</td>
<td style="text-align:left">慢</td>
</tr>
<tr>
<td style="text-align:left">MD5</td>
<td style="text-align:left">中</td>
<td style="text-align:left">快</td>
</tr>
</tbody>
</table>
<h2 id="对称加密算法比较"><a href="#对称加密算法比较" class="headerlink" title="对称加密算法比较"></a>对称加密算法比较</h2><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">密钥名称</th>
<th style="text-align:left">运行速度</th>
<th style="text-align:left">安全性</th>
<th style="text-align:left">资源消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DES</td>
<td style="text-align:left">56位</td>
<td style="text-align:left">较快</td>
<td style="text-align:left">低</td>
<td style="text-align:left">中</td>
</tr>
<tr>
<td style="text-align:left">3DES</td>
<td style="text-align:left">112位或168位</td>
<td style="text-align:left">慢</td>
<td style="text-align:left">中</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">AES</td>
<td style="text-align:left">128、192、256位</td>
<td style="text-align:left">快</td>
<td style="text-align:left">高</td>
<td style="text-align:left">低</td>
</tr>
</tbody>
</table>
<h2 id="非对称加密算法比较"><a href="#非对称加密算法比较" class="headerlink" title="非对称加密算法比较"></a>非对称加密算法比较</h2><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">成熟度</th>
<th style="text-align:left">安全性</th>
<th style="text-align:left">运算速度</th>
<th style="text-align:left">资源消耗</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">RSA</td>
<td style="text-align:left">高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">中</td>
<td style="text-align:left">中</td>
</tr>
<tr>
<td style="text-align:left">ECC</td>
<td style="text-align:left">高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">慢</td>
<td style="text-align:left">高</td>
</tr>
</tbody>
</table>
<h2 id="对称算法与非对称加密算法"><a href="#对称算法与非对称加密算法" class="headerlink" title="对称算法与非对称加密算法"></a>对称算法与非对称加密算法</h2><h3 id="对称算法"><a href="#对称算法" class="headerlink" title="对称算法"></a>对称算法</h3><ol>
<li><strong>密钥管理</strong>：比较难，不适合互联网，一般用于内部系统</li>
<li><strong>安全性</strong>：中</li>
<li><strong>加密速度</strong>：快好 <strong>几个数量级</strong> (软件加解密速度至少快 <code>100</code> 倍，每秒可以加解密数 <code>M</code> <strong>比特</strong> 数据)，适合大数据量的加解密处理</li>
</ol>
<h3 id="非对称算法"><a href="#非对称算法" class="headerlink" title="非对称算法"></a>非对称算法</h3><ol>
<li><strong>密钥管理</strong>：密钥容易管理</li>
<li><strong>安全性</strong>：高</li>
<li><strong>加密速度</strong>：比较慢，适合 <strong>小数据量</strong> 加解密或数据签名</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择Undertow替代Tomcat</title>
    <url>/2022/01/25/%E9%80%89%E6%8B%A9Undertow%E6%9B%BF%E4%BB%A3Tomcat/</url>
    <content><![CDATA[<blockquote>
<p> 一个更适合高并发系统的Web服务器</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> Spring Boot支持三个内嵌式容器Jetty , Tomcat , Undertow , 默认使用的是Tomcat。</p>
<p>Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是红帽公司的开源产品，是 <a href="http://www.oschina.net/p/wildfly">Wildfly</a> 默认的 Web 服务器。</p>
<p>Undertow 提供一个基础的架构用来构建 Web 服务器，这是一个完全为嵌入式设计的项目，提供易用的构建器 API，完全兼容 Java EE Servlet 4 和低级非堵塞的处理器。</p>
<p>Undertow设计为完全可嵌入的，并具有易于使用的流畅的Builder API。 Undertow的生命周期完全由嵌入应用程序控制。</p>
<h1 id="Undertow特点"><a href="#Undertow特点" class="headerlink" title="Undertow特点"></a>Undertow特点</h1><ul>
<li>高性能 在多款同类产品的压测中，在高并发情况下表现出色。</li>
<li>Servlet4.0 支持 它提供了对 Servlet4.0 的支持。</li>
<li>Web Socket 完全支持，包括JSR-356，用以满足 Web 应用巨大数量的客户端。</li>
<li>内嵌式 它不需要容器，只需通过 API 即可快速搭建 Web 服务器。</li>
<li>灵活性 交由链式Handler配置和处理请求，可以最小化按需加载模块，无须加载多余功能。</li>
<li>轻量级 它是一个 内嵌Web 服务器， 由两个核心 Jar 包组成</li>
</ul>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>Tomcat</p>
<p><img src="/2022/01/25/%E9%80%89%E6%8B%A9Undertow%E6%9B%BF%E4%BB%A3Tomcat/3jpstfnwbn.jpeg" alt="img"></p>
<p>Undertow</p>
<p><img src="/2022/01/25/%E9%80%89%E6%8B%A9Undertow%E6%9B%BF%E4%BB%A3Tomcat/twklpj59ox.jpeg" alt="img"></p>
<p><strong>内存使用对比：</strong></p>
<p>Tomcat</p>
<p><img src="/2022/01/25/%E9%80%89%E6%8B%A9Undertow%E6%9B%BF%E4%BB%A3Tomcat/n1bpllcixh.jpeg" alt="img"></p>
<p>Undertow</p>
<p><img src="/2022/01/25/%E9%80%89%E6%8B%A9Undertow%E6%9B%BF%E4%BB%A3Tomcat/5a3pietxhl.jpeg" alt="img"></p>
<p>通过测试发现，在高并发系统中，Tomcat相对来说比较弱。在相同的机器配置下，模拟相等的请求数，Undertow在性能和内存使用方面都是最优的。并且Undertow新版本默认使用持久连接，这将会进一步提高它的并发吞吐能力。所以，如果是高并发的业务系统，Undertow是最佳选择。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 其实在并发量不大的情况下 <code>Undertow</code>、和其它两款 Servlet Web 容器 <code>Jetty</code> 、<code>Tomcat</code> 的差距并不是很大。 <code>Undertow</code> 的优势是高并发下的吞吐量。你可以根据自己的实际需要来选择。 </p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Spring集合</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈计算机网络中的三种可靠传输机制</title>
    <url>/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p> 计算机网络中，有不可靠传输服务和可靠传输服务。不可靠传输服务对传输过程中出现的差错（比特差错、分组丢失、分组失序和分组重复）不做处理，但是可靠传输服务需要对传输过程中出现的差错进行有效的解决，保证发送方发送了什么数据接收放就收到什么数据，这就需要用到可靠传输机制去实现了。</p>
</blockquote>
<h1 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h1><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<code>停止-等待ARQ协议</code>、<code>连续ARQ协议</code>和<code>选择重传ARQ协议</code>。</p>
<h1 id="停止-等待ARQ协议"><a href="#停止-等待ARQ协议" class="headerlink" title="停止-等待ARQ协议"></a>停止-等待ARQ协议</h1><p>停止等待协议是为了实现可靠传输的，它的基本原理就是发送方给接收方发送数据分组，接收方收到后对其进行差错检测。若没有误码，则接收该数据分组，并给发送方发送确认分组，简称为ACK。发送方收到对所发送数据分组的确认分组后，才能发送下一个数据分组。若检测到误码，则丢弃该分组，并给发送方发送否认分组，简称为NAK，发送方收到对所发送数据分组的否认分组后，立刻重传该数据分组。发送方发送一个数据分组后，并不能立刻将该分组从缓存中删除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除，并发送下一个分组。</p>
<p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/1.png" alt></p>
<p>若发送分组在传输的过程中丢失了，接收方收不到数据分组，就不会发送ACK或NAK，发送方就会一直处于等待接收方ACK或NAK的状态。</p>
<p> 为解决该问题，可在发送方发送完一个数据分组时，启动一个<code>超时计时器</code>。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，即<code>超时重传</code>。</p>
<p> 一般将重传时间设为略大于从发送方到接收方的平均往返时间。</p>
<p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/2.png" alt></p>
<p>既然发送方发送的数据分组可能丢失，那么接收方发送的确认或否认分组也就有可能丢失，从而造成发送方对之前所发送数据分组的超时重传。假设该重传的数据分组正确到达了接收方，则接收方如何判断该数据分组是否是一个重复的分组呢?</p>
<p> 为避免分组重复这种错误，必须给每个数据分组带上序号。对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号足够了。</p>
<p> 接收方丢弃重复的数据分组，并给发送方发送针对该数据分组的确认分组，以免发送方对该数据分组的再次超时重传。发送方收到针对0号数据分组的确认分组，就可以发送下一个数据分组了，其序号为1。</p>
<p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/3.png" alt></p>
<p>既然数据分组需要编号，确认分组是否需要编号呢？发送方发送0号数据分组，接收方正确接收后给发送方发送确认分组。由于某些原因，该确认分组迟到了。这会导致发送方对0号数据分组的超时重传。在重传的0号数据分组的传输过程中，发送方收到了迟到的确认分组，于是发送1号数据分组。接收方收到重传的0号数据分组后，发现这是一个重复的数据分组，将其丢弃。并针对该数据分组，给发送方发送确认分组，以免发送方再次超时重传该数据分组。那么问题来了，发送方如何知道这是对0号数据分组的重复确认还是对1号数据分组的确认呢？ 如果对确认分组也进行编号，就可以使发送方避免这种误判。</p>
<p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/4.png" alt></p>
<p>优缺点：</p>
<p>优点： 简单</p>
<p>缺点： 信道利用率低，等待时间长</p>
<h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><ol>
<li>无差错情况：发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</li>
<li>出现差错情况（超时重传）：停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>确认丢失和确认迟到</li>
</ol>
<p>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</p>
<h1 id="连续ARQ协议-回退N（Go-Back-N）"><a href="#连续ARQ协议-回退N（Go-Back-N）" class="headerlink" title="连续ARQ协议/回退N（Go-Back-N）"></a>连续ARQ协议/回退N（Go-Back-N）</h1><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/5.png" alt></p>
<h2 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h2><ul>
<li><p>发送窗口尺寸Wt的取值范围是1 &lt; Wt &lt;= 2^n - 1，其中，n是构成分组序号的比特数量。Wt = 1 停止-等待协议；Wt &gt; 2^n - 1，接收方无法分辨新旧数据分组。</p>
</li>
<li><p>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去；</p>
</li>
<li>发送方只有收到对以发送数据分组的确认时，发送窗口才能向前相应滑动；</li>
<li>发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定；</li>
<li>发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传。</li>
</ul>
<h2 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h2><ul>
<li>接收方的接收窗口尺寸Wr的取值范围是Wr = 1，因此接收方只能按序接收数据分组；</li>
<li>接收方只接收序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组。为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组，而是可以在连续收到好几个按序到达且无误码的数据分组后，才针对最后一个数据分组发送确认分组，称为累计确认；或者可以在自己有数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认。</li>
<li>接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认。</li>
</ul>
<p>优缺点：</p>
<p>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。</p>
<h1 id="选择重传ARQ协议"><a href="#选择重传ARQ协议" class="headerlink" title="选择重传ARQ协议"></a>选择重传ARQ协议</h1><p><img src="/2021/04/02/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/6.png" alt></p>
<h2 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h2><ul>
<li>发送窗口尺寸Wr的取值范围为1 &lt; Wt &lt;= 2^(n - 1)，其中，n是构成分组序号的比特数量。</li>
</ul>
<ol>
<li><p>Wt = 1，与停止-等待协议相同</p>
</li>
<li><p>Wt &gt; 2^(n - 1)，接收方无法分辨新，旧数据分组</p>
</li>
</ol>
<ul>
<li>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去；</li>
<li>发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动。</li>
</ul>
<h2 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h2><ul>
<li>接收窗口尺寸Wr的取值范围是1 &lt; Wr &lt;= Wt</li>
</ul>
<ol>
<li><p>Wr = 1，与停止-等待协议相同</p>
</li>
<li><p>Wr &gt; Wt，无意义</p>
</li>
</ol>
<ul>
<li>接收方可接收未按序到达但没有误码且序号落在接收窗口内的数据分组；为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认。</li>
<li>接收方只有在按序接收数据分组后，接收窗口才能向前相应滑动。</li>
</ul>
<p>优缺点：</p>
<p>优点： 不需要发送没必要的帧，效率高</p>
<p>缺点： 相对于回退N复杂度高</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
